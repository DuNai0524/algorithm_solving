### 解题思路

本题是模拟题中比较适合做面试题的一种类型，主要难点在于将逻辑用代码准确的表达出来。建议同学在实现代码的时候可以多多输出中间变量验证自己代码的正确性。
「微扰酱」的做法主要分为两部：
1. 确定n对应的数字是几位数字
2. 计算具体是哪一个数字

我们知道 0-9 是一位数， 一位数共有9个， 总计产生 9 * 1 = 9 位数字
我们知道 10-99 是两位数， 两位数共有90个， 总计产生 90 * 2 = 180 位数字
...

依次类推，我们可以把digit位数里产生的数字个数算出来它等于 $9*10^{digit-1}*digit$ 位数字。
由此通过一个循环，对不同位数一共产生了多少位数字做累计并和n进行比较，我们就可以判断出n对应的数字是几位数字。

第二步；我们找到这个具体的数字，假设n对应的数字是target。
我们先扣掉比target位数低的数字一共占用了多少位。这个在第一步里就求出来了，假设得到的值为N。
剩余的N都是由 digits位数 贡献的，因而我们求除求余就可以知道n对应的是第几个digits位数。

### 举个例子

以190为例。
第一步我们会扣掉 9+180 = 189； 得到190对应的是一个三位数。 且 190 - 189 = 1 即说明190是第一个三位数。
(1 - 1) / 3 = 0
(1 - 1) % 3 = 0
说明190是第一个三位数的第一个数字。 而第一个三位数是100，从而得到答案1。

翻译成代码如下：

### 代码

* cpp

```cpp
class Solution {
public:
    int findNthDigit(int n) {
        long long N = n;
        int digits = 1; // 位数
        long long border = 9; // digits位数一共产生多少位数字

        while(N) {
            if (N <= border*digits) break; // 循环退出时即找到了当前数字的位数
            N -= border*digits; // N 为扣掉所有digits位数字（比如2位数）产生的数字之后还剩多少个数字
            digits++;
            border *= 10;
        }
        // 循环结束后 剩余的N都是由 digits位数 贡献的
        // 每个 digits位数 都产生了 digits个数字； 因而我们求除求余就可以知道n对应的是第几个digits位数
        int offset = (N - 1) / digits;
        int begin = 1; // 用于计算最小的 digits位数
        for (int i = 0; i < digits - 1; i++) {
            begin *= 10;
        }
        int mod = (N - 1) % digits;
        string target = to_string(offset+begin);
        int ans = target[mod] - '0';

        return ans;        
    }
};
```

### 关于我

大家好，我是微扰酱。现在是五道口【悖论13】剧本杀的股东之一，点评搜索即可，欢迎大家来探店。
微扰酱18年毕业于上海交通大学，是一个在阿里、字节、腾讯都工作过的工程师，有丰富的面试经验。从 2021.4 开始在emqx从事存储研发，希望在今年多多输出。

最后，如果对你有帮助，**可以点个赞支持一下我哦** 也欢迎在leetcode上[关注我](https://leetcode-cn.com/u/wfnuser/)。

欢迎留言预定配图！ 周末沉迷国王排名，非常好看... 周赛...就又咕咕咕了。
![image.png](https://pic.leetcode-cn.com/1638108617-WhxKwm-image.png)
