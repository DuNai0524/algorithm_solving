### 解题思路：

这道题比较容易想到的有两种解法：

+ 先排序再遍历的方法，时间复杂度 $O(n \log n)$
+ 计数方法，时间复杂度 $O(n + k)$，其中 $k$ 是整数的取值范围大小

#### 方法一：先排序再遍历

首先将数组进行排序，然后从左到右遍历数组：

+ 如果当前元素大于上一个元素，保持不变；
+ 如果当前元素小于等于上一个元素，就需要增加当前元素，直到大于上一个元素。

例如输入 `[3, 2, 1, 2, 1, 7]`，排序后为 `[1, 1, 2, 2, 3, 7]`。遍历数组的过程如下图所示：

![数字增加的过程（动图）](https://pic.leetcode-cn.com/f8e4a4eef34707b6d046599690bb0dda19f8ebea8aa6025cffdd19328de35e15.gif)

写成代码，只需要用一个变量保存当前的最大值即可。题解代码：

* []

```Java
public int minIncrementForUnique(int[] A) {
    Arrays.sort(A); // 先排序
    int curmax = -1; // 当前数组最大值
    int res = 0;
    for (int i = 0; i < A.length; i++) {
        if (A[i] <= curmax) {
            // 当前元素 A[i] 需要增加到 curmax + 1
            res += (curmax + 1 - A[i]); // 记录自增次数
        }
        curmax = Math.max(curmax + 1, A[i]);
    }
    return res;
}
```

时间复杂度：$O(n \log n)$，主要的复杂度在排序上。

#### 方法二：先计数再遍历

上面方法中，排序需要 $O(n \log n)$ 的时间，比较昂贵。我们尝试不进行排序的方法。

例如输入 `[3, 2, 1, 2, 1, 7]`，计数之后有两个 1 和两个 2。我们先看最小的数，两个 1 重复了，需要有一个增加到 2，这样 2 的数量变成了三个。在三个 2 中，又有两个需要增加到 3，然后又出现了两个 3…… 以此类推，可以计算出需要增加的次数。

我们可以用 map（如 C++ 的 `unordered_map`，Java 的 `HashMap`）来做计数。不过既然题目中说明了整数的范围在 0 到 40000 之间，我们不妨直接用一个大小为 40000 的数组做计数。

需要注意的是，虽然整数的范围是 0 到 40000，但是由于整数还会因为增加而变大，超出 40000 的范围。例如极端的情况：所有数都是 39999。所以需要对整数中最大的数单独处理。代码如下：

* []

```Java
public int minIncrementForUnique(int[] A) {
    int[] count = new int[40000];
    int max = 0;
    for (int a : A) {
        count[a]++; // 计数
        max = Math.max(max, a); // 计算数组中的最大值
    }
    
    int res = 0;
    for (int j = 0; j < max; j++) {
        if (count[j] > 1) {
            // 有 count[j] - 1 个数需要增加
            res += count[j] - 1; 
            count[j+1] += count[j] - 1;
        }
    }
    
    // count[max] 单独计算，是因为可能超出 40000 的边界
    if (count[max] > 1) {
        int d = count[max] - 1; 
        // 有 d 个数需要增加
        // 分别增加为 max + 1, max + 2, ... max + d
        // 使用等差数列公式求和
        res += (1 + d) * d / 2;
    }
    
    return res;
}
```

这种解法的时间复杂度不能简单地写成 $O(n)$。设 $n$ 为数组元素的个数，$k$ 为数组元素的**可能取值个数**（本期中 $k = 40000$），这个算法的时间复杂度是 $O(n + k)$。

#### 两种解法的时间复杂度比较

+ 先排序再遍历的方法，时间复杂度 $O(n \log n)$
+ 计数方法，时间复杂度 $O(n + k)$

如果 $k$ 比较小的话，计数方法的时间复杂度可以认为是 $O(n)$，比排序方法要快。这道题 $k$ 取值 40000 算比较小的数，所以用计数方法会很快。如果 $k$ 的值很大，就不能用计数方法。

虽然计数方法不需要排序，但我们可以把它看成是一种[**计数排序**](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)。计数排序的时间复杂度恰好也是 $O(n + k)$。所以实际上两种方法都是用的排序，只不过一个是普通排序，一个是计数排序。我们在算法书中学过，计数排序这种排序方法是**非比较排序**，可以突破 $O(n \log n)$ 的复杂度下限。但是它会对输入的性质有所要求，例如要求 $k$ 比较小。

如果你能理解比较排序和非比较排序的关系，就很容易理解这两种解法的时间复杂度的关系了。

