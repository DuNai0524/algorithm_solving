# ç®—æ³•å…¬å¼€è¯¾

**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[å›æº¯ç®—æ³•å¦‚ä½•åˆ†å‰²å­—ç¬¦ä¸²å¹¶åˆ¤æ–­æ˜¯åˆæ³•IPï¼Ÿ| LeetCodeï¼š93.å¤åŸIPåœ°å€](https://www.bilibili.com/video/BV1XP4y1U73i/)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

# æ€è·¯

åšè¿™é“é¢˜ç›®ä¹‹å‰ï¼Œæœ€å¥½å…ˆæŠŠ[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)è¿™ä¸ªåšäº†ã€‚

è¿™é“é¢˜ç›®ç›¸ä¿¡å¤§å®¶åˆšçœ‹çš„æ—¶å€™ï¼Œåº”è¯¥ä¼šä¸€è„¸èŒ«ç„¶ã€‚

å…¶å®åªè¦æ„è¯†åˆ°è¿™æ˜¯åˆ‡å‰²é—®é¢˜ï¼Œ**åˆ‡å‰²é—®é¢˜å°±å¯ä»¥ä½¿ç”¨å›æº¯æœç´¢æ³•æŠŠæ‰€æœ‰å¯èƒ½æ€§æœå‡ºæ¥**ï¼Œå’Œåˆšåšè¿‡çš„[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)å°±ååˆ†ç±»ä¼¼äº†ã€‚

åˆ‡å‰²é—®é¢˜å¯ä»¥æŠ½è±¡ä¸ºæ ‘å‹ç»“æ„ï¼Œå¦‚å›¾ï¼š

![image.png](https://pic.leetcode.cn/1674873864-ujwWkJ-image.png)

## å›æº¯ä¸‰éƒ¨æ›²

* é€’å½’å‚æ•°

åœ¨[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)ä¸­æˆ‘ä»¬å°±æåˆ°åˆ‡å‰²é—®é¢˜ç±»ä¼¼ç»„åˆé—®é¢˜ã€‚

startIndexä¸€å®šæ˜¯éœ€è¦çš„ï¼Œå› ä¸ºä¸èƒ½é‡å¤åˆ†å‰²ï¼Œè®°å½•ä¸‹ä¸€å±‚é€’å½’åˆ†å‰²çš„èµ·å§‹ä½ç½®ã€‚

æœ¬é¢˜æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå˜é‡pointNumï¼Œè®°å½•æ·»åŠ é€—ç‚¹çš„æ•°é‡ã€‚

æ‰€ä»¥ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
vector<string> result;// è®°å½•ç»“æœ
// startIndex: æœç´¢çš„èµ·å§‹ä½ç½®ï¼ŒpointNum:æ·»åŠ é€—ç‚¹çš„æ•°é‡
void backtracking(string& s, int startIndex, int pointNum) {
```

* é€’å½’ç»ˆæ­¢æ¡ä»¶

ç»ˆæ­¢æ¡ä»¶å’Œ[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)æƒ…å†µå°±ä¸åŒäº†ï¼Œæœ¬é¢˜æ˜ç¡®è¦æ±‚åªä¼šåˆ†æˆ4æ®µï¼Œæ‰€ä»¥ä¸èƒ½ç”¨åˆ‡å‰²çº¿åˆ‡åˆ°æœ€åä½œä¸ºç»ˆæ­¢æ¡ä»¶ï¼Œè€Œæ˜¯åˆ†å‰²çš„æ®µæ•°ä½œä¸ºç»ˆæ­¢æ¡ä»¶ã€‚

pointNumè¡¨ç¤ºé€—ç‚¹æ•°é‡ï¼ŒpointNumä¸º3è¯´æ˜å­—ç¬¦ä¸²åˆ†æˆäº†4æ®µäº†ã€‚

ç„¶åéªŒè¯ä¸€ä¸‹ç¬¬å››æ®µæ˜¯å¦åˆæ³•ï¼Œå¦‚æœåˆæ³•å°±åŠ å…¥åˆ°ç»“æœé›†é‡Œ

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
if (pointNum == 3) { // é€—ç‚¹æ•°é‡ä¸º3æ—¶ï¼Œåˆ†éš”ç»“æŸ
    // åˆ¤æ–­ç¬¬å››æ®µå­å­—ç¬¦ä¸²æ˜¯å¦åˆæ³•ï¼Œå¦‚æœåˆæ³•å°±æ”¾è¿›resultä¸­
    if (isValid(s, startIndex, s.size() - 1)) {
        result.push_back(s);
    }
    return;
}
```

* å•å±‚æœç´¢çš„é€»è¾‘

åœ¨[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)ä¸­å·²ç»è®²è¿‡åœ¨å¾ªç¯éå†ä¸­å¦‚ä½•æˆªå–å­ä¸²ã€‚

åœ¨`for (int i = startIndex; i < s.size(); i++)`å¾ªç¯ä¸­ [startIndex, i] è¿™ä¸ªåŒºé—´å°±æ˜¯æˆªå–çš„å­ä¸²ï¼Œéœ€è¦åˆ¤æ–­è¿™ä¸ªå­ä¸²æ˜¯å¦åˆæ³•ã€‚

å¦‚æœåˆæ³•å°±åœ¨å­—ç¬¦ä¸²åé¢åŠ ä¸Šç¬¦å·`.`è¡¨ç¤ºå·²ç»åˆ†å‰²ã€‚

å¦‚æœä¸åˆæ³•å°±ç»“æŸæœ¬å±‚å¾ªç¯ï¼Œå¦‚å›¾ä¸­å‰ªæ‰çš„åˆ†æ”¯ï¼š

![image.png](https://pic.leetcode.cn/1674873864-ujwWkJ-image.png)

ç„¶åå°±æ˜¯é€’å½’å’Œå›æº¯çš„è¿‡ç¨‹ï¼š

é€’å½’è°ƒç”¨æ—¶ï¼Œä¸‹ä¸€å±‚é€’å½’çš„startIndexè¦ä»i+2å¼€å§‹ï¼ˆå› ä¸ºéœ€è¦åœ¨å­—ç¬¦ä¸²ä¸­åŠ å…¥äº†åˆ†éš”ç¬¦`.`ï¼‰ï¼ŒåŒæ—¶è®°å½•åˆ†å‰²ç¬¦çš„æ•°é‡pointNum è¦ +1ã€‚

å›æº¯çš„æ—¶å€™ï¼Œå°±å°†åˆšåˆšåŠ å…¥çš„åˆ†éš”ç¬¦`.` åˆ æ‰å°±å¯ä»¥äº†ï¼ŒpointNumä¹Ÿè¦-1ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
for (int i = startIndex; i < s.size(); i++) {
    if (isValid(s, startIndex, i)) { // åˆ¤æ–­ [startIndex,i] è¿™ä¸ªåŒºé—´çš„å­ä¸²æ˜¯å¦åˆæ³•
        s.insert(s.begin() + i + 1 , '.');  // åœ¨içš„åé¢æ’å…¥ä¸€ä¸ªé€—ç‚¹
        pointNum++;
        backtracking(s, i + 2, pointNum);   // æ’å…¥é€—ç‚¹ä¹‹åä¸‹ä¸€ä¸ªå­ä¸²çš„èµ·å§‹ä½ç½®ä¸ºi+2
        pointNum--;                         // å›æº¯
        s.erase(s.begin() + i + 1);         // å›æº¯åˆ æ‰é€—ç‚¹
    } else break; // ä¸åˆæ³•ï¼Œç›´æ¥ç»“æŸæœ¬å±‚å¾ªç¯
}
```

## åˆ¤æ–­å­ä¸²æ˜¯å¦åˆæ³•

æœ€åå°±æ˜¯åœ¨å†™ä¸€ä¸ªåˆ¤æ–­æ®µä½æ˜¯å¦æ˜¯æœ‰æ•ˆæ®µä½äº†ã€‚

ä¸»è¦è€ƒè™‘åˆ°å¦‚ä¸‹ä¸‰ç‚¹ï¼š

* æ®µä½ä»¥0ä¸ºå¼€å¤´çš„æ•°å­—ä¸åˆæ³•
* æ®µä½é‡Œæœ‰éæ­£æ•´æ•°å­—ç¬¦ä¸åˆæ³•
* æ®µä½å¦‚æœå¤§äº255äº†ä¸åˆæ³•

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
// åˆ¤æ–­å­—ç¬¦ä¸²såœ¨å·¦é—­åˆé—­åŒºé—´[start, end]æ‰€ç»„æˆçš„æ•°å­—æ˜¯å¦åˆæ³•
bool isValid(const string& s, int start, int end) {
    if (start > end) {
        return false;
    }
    if (s[start] == '0' && start != end) { // 0å¼€å¤´çš„æ•°å­—ä¸åˆæ³•
            return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++) {
        if (s[i] > '9' || s[i] < '0') { // é‡åˆ°éæ•°å­—å­—ç¬¦ä¸åˆæ³•
            return false;
        }
        num = num * 10 + (s[i] - '0');
        if (num > 255) { // å¦‚æœå¤§äº255äº†ä¸åˆæ³•
            return false;
        }
    }
    return true;
}
```

## C++ä»£ç 

æ ¹æ®[å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)ç»™å‡ºçš„å›æº¯ç®—æ³•æ¨¡æ¿ï¼š

* 

```
void backtracking(å‚æ•°) {
    if (ç»ˆæ­¢æ¡ä»¶) {
        å­˜æ”¾ç»“æœ;
        return;
    }

    for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) {
        å¤„ç†èŠ‚ç‚¹;
        backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’
        å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
    }
}
```

å¯ä»¥å†™å‡ºå¦‚ä¸‹å›æº¯ç®—æ³•C++ä»£ç ï¼š

* CPP

```CPP
class Solution {
private:
    vector<string> result;// è®°å½•ç»“æœ
    // startIndex: æœç´¢çš„èµ·å§‹ä½ç½®ï¼ŒpointNum:æ·»åŠ é€—ç‚¹çš„æ•°é‡
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // é€—ç‚¹æ•°é‡ä¸º3æ—¶ï¼Œåˆ†éš”ç»“æŸ
            // åˆ¤æ–­ç¬¬å››æ®µå­å­—ç¬¦ä¸²æ˜¯å¦åˆæ³•ï¼Œå¦‚æœåˆæ³•å°±æ”¾è¿›resultä¸­
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isValid(s, startIndex, i)) { // åˆ¤æ–­ [startIndex,i] è¿™ä¸ªåŒºé—´çš„å­ä¸²æ˜¯å¦åˆæ³•
                s.insert(s.begin() + i + 1 , '.');  // åœ¨içš„åé¢æ’å…¥ä¸€ä¸ªé€—ç‚¹
                pointNum++;
                backtracking(s, i + 2, pointNum);   // æ’å…¥é€—ç‚¹ä¹‹åä¸‹ä¸€ä¸ªå­ä¸²çš„èµ·å§‹ä½ç½®ä¸ºi+2
                pointNum--;                         // å›æº¯
                s.erase(s.begin() + i + 1);         // å›æº¯åˆ æ‰é€—ç‚¹
            } else break; // ä¸åˆæ³•ï¼Œç›´æ¥ç»“æŸæœ¬å±‚å¾ªç¯
        }
    }
    // åˆ¤æ–­å­—ç¬¦ä¸²såœ¨å·¦é—­åˆé—­åŒºé—´[start, end]æ‰€ç»„æˆçš„æ•°å­—æ˜¯å¦åˆæ³•
    bool isValid(const string& s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) { // 0å¼€å¤´çš„æ•°å­—ä¸åˆæ³•
                return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // é‡åˆ°éæ•°å­—å­—ç¬¦ä¸åˆæ³•
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // å¦‚æœå¤§äº255äº†ä¸åˆæ³•
                return false;
            }
        }
        return true;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        if (s.size() < 4 || s.size() > 12) return result; // ç®—æ˜¯å‰ªæäº†
        backtracking(s, 0, 0);
        return result;
    }
};

```

# æ€»ç»“

åœ¨[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)ä¸­æˆ‘åˆ—ä¸¾çš„åˆ†å‰²å­—ç¬¦ä¸²çš„éš¾ç‚¹ï¼Œæœ¬é¢˜éƒ½è¦†ç›–äº†ã€‚

è€Œä¸”æœ¬é¢˜è¿˜éœ€è¦æ“ä½œå­—ç¬¦ä¸²æ·»åŠ é€—å·ä½œä¸ºåˆ†éš”ç¬¦ï¼Œå¹¶éªŒè¯åŒºé—´çš„åˆæ³•æ€§ã€‚

å¯ä»¥è¯´æ˜¯[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)çš„åŠ å¼ºç‰ˆã€‚

åœ¨æœ¬æ–‡çš„æ ‘å½¢ç»“æ„å›¾ä¸­ï¼Œæˆ‘å·²ç»æŠŠè¯¦ç»†çš„åˆ†ææ€è·¯éƒ½ç”»äº†å‡ºæ¥ï¼Œç›¸ä¿¡å¤§å®¶çœ‹äº†ä¹‹åä¸€å®šä¼šæ€è·¯æ¸…æ™°ä¸å°‘ï¼

# å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```java
class Solution {
    List<String> result = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12) return result; // ç®—æ˜¯å‰ªæäº†
        backTrack(s, 0, 0);
        return result;
    }

    // startIndex: æœç´¢çš„èµ·å§‹ä½ç½®ï¼Œ pointNum:æ·»åŠ é€—ç‚¹çš„æ•°é‡
    private void backTrack(String s, int startIndex, int pointNum) {
        if (pointNum == 3) {// é€—ç‚¹æ•°é‡ä¸º3æ—¶ï¼Œåˆ†éš”ç»“æŸ
            // åˆ¤æ–­ç¬¬å››æ®µâ¼¦å­—ç¬¦ä¸²æ˜¯å¦åˆæ³•ï¼Œå¦‚æœåˆæ³•å°±æ”¾è¿›resultä¸­
            if (isValid(s,startIndex,s.length()-1)) {
                result.add(s);
            }
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            if (isValid(s, startIndex, i)) {
                s = s.substring(0, i + 1) + "." + s.substring(i + 1);    //åœ¨strçš„åâ¾¯æ’â¼Šâ¼€ä¸ªé€—ç‚¹
                pointNum++;
                backTrack(s, i + 2, pointNum);// æ’â¼Šé€—ç‚¹ä¹‹åä¸‹â¼€ä¸ªâ¼¦ä¸²çš„èµ·å§‹ä½ç½®ä¸ºi+2
                pointNum--;// å›æº¯
                s = s.substring(0, i + 1) + s.substring(i + 2);// å›æº¯åˆ æ‰é€—ç‚¹
            } else {
                break;
            }
        }
    }

    // åˆ¤æ–­å­—ç¬¦ä¸²såœ¨å·¦é—­â¼œé—­åŒºé—´[start, end]æ‰€ç»„æˆçš„æ•°å­—æ˜¯å¦åˆæ³•
    private Boolean isValid(String s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s.charAt(start) == '0' && start != end) { // 0å¼€å¤´çš„æ•°å­—ä¸åˆæ³•
            return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0') { // é‡åˆ°â¾®æ•°å­—å­—ç¬¦ä¸åˆæ³•
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');
            if (num > 255) { // å¦‚æœâ¼¤äº255äº†ä¸åˆæ³•
                return false;
            }
        }
        return true;
    }
}

//æ–¹æ³•äºŒï¼šæ¯”ä¸Šé¢çš„æ–¹æ³•æ—¶é—´å¤æ‚åº¦ä½ï¼Œæ›´å¥½åœ°å‰ªæï¼Œä¼˜åŒ–æ—¶é—´å¤æ‚åº¦
class Solution {
    List<String> result = new ArrayList<String>();
	StringBuilder stringBuilder = new StringBuilder();

	public List<String> restoreIpAddresses(String s) {
		restoreIpAddressesHandler(s, 0, 0);
		return result;
	}

	// numberè¡¨ç¤ºstringbuilderä¸­ipæ®µçš„æ•°é‡
	public void restoreIpAddressesHandler(String s, int start, int number) {
		// å¦‚æœstartç­‰äºsçš„é•¿åº¦å¹¶ä¸”ipæ®µçš„æ•°é‡æ˜¯4ï¼Œåˆ™åŠ å…¥ç»“æœé›†ï¼Œå¹¶è¿”å›
		if (start == s.length() && number == 4) {
			result.add(stringBuilder.toString());
			return;
		}
		// å¦‚æœstartç­‰äºsçš„é•¿åº¦ä½†æ˜¯ipæ®µçš„æ•°é‡ä¸ä¸º4ï¼Œæˆ–è€…ipæ®µçš„æ•°é‡ä¸º4ä½†æ˜¯startå°äºsçš„é•¿åº¦ï¼Œåˆ™ç›´æ¥è¿”å›
		if (start == s.length() || number == 4) {
			return;
		}
		// å‰ªæï¼šipæ®µçš„é•¿åº¦æœ€å¤§æ˜¯3ï¼Œå¹¶ä¸”ipæ®µå¤„äº[0,255]
		for (int i = start; i < s.length() && i - start < 3 && Integer.parseInt(s.substring(start, i + 1)) >= 0
				&& Integer.parseInt(s.substring(start, i + 1)) <= 255; i++) {
			// å¦‚æœipæ®µçš„é•¿åº¦å¤§äº1ï¼Œå¹¶ä¸”ç¬¬ä¸€ä½ä¸º0çš„è¯ï¼Œcontinue
			if (i + 1 - start > 1 && s.charAt(start) - '0' == 0) {
				continue;
			}
			stringBuilder.append(s.substring(start, i + 1));
			// å½“stringBuilderé‡Œçš„ç½‘æ®µæ•°é‡å°äº3æ—¶ï¼Œæ‰ä¼šåŠ ç‚¹ï¼›å¦‚æœç­‰äº3ï¼Œè¯´æ˜å·²ç»æœ‰3æ®µäº†ï¼Œæœ€åä¸€æ®µä¸éœ€è¦å†åŠ ç‚¹
			if (number < 3) {
				stringBuilder.append(".");
			}
			number++;
			restoreIpAddressesHandler(s, i + 1, number);
			number--;
			// åˆ é™¤å½“å‰stringBuilderæœ€åä¸€ä¸ªç½‘æ®µï¼Œæ³¨æ„è€ƒè™‘ç‚¹çš„æ•°é‡çš„é—®é¢˜
			stringBuilder.delete(start + number, i + number + 2);
		}
	}
}
```

* []

```python
class Solution(object):
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        ans = []
        path = []
        def backtrack(path, startIndex):
            if len(s) > 12: return []
            if len(path) == 4:
                if startIndex == len(s):
                    ans.append(".".join(path[:]))
                    return
            for i in range(startIndex+1, min(startIndex+4, len(s)+1)):  # å‰ªæ
                string = s[startIndex:i]
                if not 0 <= int(string) <= 255:
                    continue
                if not string == "0" and not string.lstrip('0') == string:
                    continue
                path.append(string)
                backtrack(path, i)
                path.pop()

        backtrack([], 0)
        return ans

# python3:
class Solution:
    def __init__(self):
        self.result = []

    def restoreIpAddresses(self, s: str) -> List[str]:
        '''
        æœ¬è´¨åˆ‡å‰²é—®é¢˜ä½¿ç”¨å›æº¯æœç´¢æ³•ï¼Œæœ¬é¢˜åªèƒ½åˆ‡å‰²ä¸‰æ¬¡ï¼Œæ‰€ä»¥çºµå‘é€’å½’æ€»å…±å››å±‚
        å› ä¸ºä¸èƒ½é‡å¤åˆ†å‰²ï¼Œæ‰€ä»¥éœ€è¦start_indexæ¥è®°å½•ä¸‹ä¸€å±‚é€’å½’åˆ†å‰²çš„èµ·å§‹ä½ç½®
        æ·»åŠ å˜é‡point_numæ¥è®°å½•é€—å·çš„æ•°é‡[0,3]
        '''
        self.result.clear()
        if len(s) > 12: return []
        self.backtracking(s, 0, 0)
        return self.result

    def backtracking(self, s: str, start_index: int, point_num: int) -> None:
        # Base Case
        if point_num == 3:
            if self.is_valid(s, start_index, len(s)-1):
                self.result.append(s[:])
            return
        # å•å±‚é€’å½’é€»è¾‘
        for i in range(start_index, len(s)):
            # [start_index, i]å°±æ˜¯è¢«æˆªå–çš„å­ä¸²
            if self.is_valid(s, start_index, i):
                s = s[:i+1] + '.' + s[i+1:]
                self.backtracking(s, i+2, point_num+1)  # åœ¨å¡«å…¥.åï¼Œä¸‹ä¸€å­ä¸²èµ·å§‹åç§»2ä½
                s = s[:i+1] + s[i+2:]    # å›æº¯
            else:
                # è‹¥å½“å‰è¢«æˆªå–çš„å­ä¸²å¤§äº255æˆ–è€…å¤§äºä¸‰ä½æ•°ï¼Œç›´æ¥ç»“æŸæœ¬å±‚å¾ªç¯
                break
    
    def is_valid(self, s: str, start: int, end: int) -> bool:
        if start > end: return False
        # è‹¥æ•°å­—æ˜¯0å¼€å¤´ï¼Œä¸åˆæ³•
        if s[start] == '0' and start != end:
            return False
        if not 0 <= int(s[start:end+1]) <= 255:
            return False
        return True
```

* []

```go
var (
    path []string
    res  []string
)
func restoreIpAddresses(s string) []string {
    path, res = make([]string, 0, len(s)), make([]string, 0)
    dfs(s, 0)
    return res
}
func dfs(s string, start int) {  
    if len(path) == 4 {    // å¤Ÿå››æ®µåå°±ä¸å†ç»§ç»­å¾€ä¸‹é€’å½’
        if start == len(s) {      
            str := strings.Join(path, ".")
            res = append(res, str)
        }
        return 
    }
    for i := start; i < len(s); i++ {
        if i != start && s[start] == '0' { // å«æœ‰å‰å¯¼ 0ï¼Œæ— æ•ˆ
            break
        }
        str := s[start : i+1]
        num, _ := strconv.Atoi(str)
        if num >= 0 && num <= 255 {
            path = append(path, str)  // ç¬¦åˆæ¡ä»¶çš„å°±è¿›å…¥ä¸‹ä¸€å±‚
            dfs(s, i+1)
            path = path[:len(path) - 1]
        } else {   // å¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œå†å¾€åä¹Ÿä¸å¯èƒ½æ»¡è¶³æ¡ä»¶ï¼Œç›´æ¥é€€å‡º
            break
        }
    }
}
```

* []

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
    const res = [], path = [];
    backtracking(0, 0)
    return res;
    function backtracking(i) {
        const len = path.length;
        if(len > 4) return;
        if(len === 4 && i === s.length) {
            res.push(path.join("."));
            return;
        }
        for(let j = i; j < s.length; j++) {
            const str = s.slice(i, j + 1);
            if(str.length > 3 || +str > 255) break;
            if(str.length > 1 && str[0] === "0") break;
            path.push(str);
            backtracking(j + 1);
            path.pop()
        }
    }
};
```

* []

```typescript
function isValidIpSegment(str: string): boolean {
    let resBool: boolean = true;
    let tempVal: number = Number(str);
    if (
        str.length === 0 || isNaN(tempVal) ||
        tempVal > 255 || tempVal < 0 ||
        (str.length > 1 && str[0] === '0')
    ) {
        resBool = false;
    }
    return resBool;
}
function restoreIpAddresses(s: string): string[] {
    const resArr: string[] = [];
    backTracking(s, 0, []);
    return resArr;
    function backTracking(s: string, startIndex: number, route: string[]): void {
        let length: number = s.length;
        if (route.length === 4 && startIndex >= length) {
            resArr.push(route.join('.'));
            return;
        }
        if (route.length === 4 || startIndex >= length) return;
        let tempStr: string = '';
        for (let i = startIndex + 1; i <= Math.min(length, startIndex + 3); i++) {
            tempStr = s.slice(startIndex, i);
            if (isValidIpSegment(tempStr)) {
                route.push(s.slice(startIndex, i));
                backTracking(s, i, route);
                route.pop();
            }
        }
    }
};
```

* []

```Rust
impl Solution {
    fn is_valid(s: &Vec<char>, start: usize, end: usize) -> bool {
        if start > end { return false; }
        if s[start] == '0' && start != end { return false; }
        let mut num = 0;
        for i in start..=end {
            if s[i] > '9' || s[i] < '0' { return false; }
            if let Some(digit) = s[i].to_digit(10) { num = num * 10 + digit; }
            if num > 255 { return false; }
        }
        true
    }

    fn backtracking(result: &mut Vec<String>, s: &mut Vec<char>, start_index: usize, mut point_num: usize) {
        let len = s.len();
        if point_num == 3 {
            if Self::is_valid(s, start_index, len - 1) {
                result.push(s.iter().collect::<String>());
            }
            return;
        }
        for i in start_index..len {
            if Self::is_valid(s, start_index, i) {
                point_num += 1;
                s.insert(i + 1, '.');
                Self::backtracking(result, s, i + 2, point_num);
                point_num -= 1;
                s.remove(i + 1);
            }   else { break; }
        }
    }

    pub fn restore_ip_addresses(s: String) -> Vec<String> {
        let mut result: Vec<String> = Vec::new();
        let len = s.len();
        if len < 4 || len > 12 { return result; }
        let mut s = s.chars().collect::<Vec<char>>();
        Self::backtracking(&mut result, &mut s, 0, 0);
        result
    }

}
```

* []

```c
//è®°å½•ç»“æœ
char** result;
int resultTop;
//è®°å½•åº”è¯¥åŠ å…¥'.'çš„ä½ç½®
int segments[3];
int isValid(char* s, int start, int end) {
    if(start > end)
        return 0;
    if (s[start] == '0' && start != end) { // 0å¼€å¤´çš„æ•°å­—ä¸åˆæ³•
                return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++) {
        if (s[i] > '9' || s[i] < '0') { // é‡åˆ°éæ•°å­—å­—ç¬¦ä¸åˆæ³•
            return false;
        }
        num = num * 10 + (s[i] - '0');
        if (num > 255) { // å¦‚æœå¤§äº255äº†ä¸åˆæ³•
            return false;
        }
    }
    return true;
}

//startIndexä¸ºèµ·å§‹æœç´¢ä½ç½®ï¼ŒpointNumä¸º'.'å¯¹è±¡
void backTracking(char* s, int startIndex, int pointNum) {
    //è‹¥'.'æ•°é‡ä¸º3ï¼Œåˆ†éš”ç»“æŸ
    if(pointNum == 3) {
        //è‹¥æœ€åä¸€æ®µå­—ç¬¦ä¸²ç¬¦åˆè¦æ±‚ï¼Œå°†å½“å‰çš„å­—ç¬¦ä¸²æ”¾å…¥resultç§
        if(isValid(s, startIndex, strlen(s) - 1)) {
            char* tempString = (char*)malloc(sizeof(char) * strlen(s) + 4);
            int j;
            //è®°å½•æ·»åŠ å­—ç¬¦æ—¶tempStringçš„ä¸‹æ ‡
            int count = 0;
            //è®°å½•æ·»åŠ å­—ç¬¦æ—¶'.'çš„ä½¿ç”¨æ•°é‡
            int count1 = 0;
            for(j = 0; j < strlen(s); j++) {
                tempString[count++] = s[j];
                //è‹¥'.'çš„ä½¿ç”¨æ•°é‡å°äº3ä¸”å½“å‰ä¸‹æ ‡ç­‰äº'.'ä¸‹æ ‡ï¼Œæ·»åŠ '.'åˆ°æ•°ç»„
                if(count1 < 3 && j == segments[count1]) {
                    tempString[count++] = '.';
                    count1++;
                }
            }
            tempString[count] = 0;
            //æ‰©å®¹resultæ•°ç»„
            result = (char**)realloc(result, sizeof(char*) * (resultTop + 1));
            result[resultTop++] = tempString;
        }
        return ;
    }

    int i;
    for(i = startIndex; i < strlen(s); i++) {
        if(isValid(s, startIndex, i)) {
            //è®°å½•åº”è¯¥æ·»åŠ '.'çš„ä½ç½®
            segments[pointNum] = i;
            backTracking(s, i + 1, pointNum + 1);
        }
        else {
            break;
        }
    }
}

char ** restoreIpAddresses(char * s, int* returnSize){
    result = (char**)malloc(0);
    resultTop = 0;
    backTracking(s, 0, 0);
    *returnSize = resultTop;
    return result;
}
```

* []

```swift
// åˆ¤æ–­åŒºé—´æ®µæ˜¯å¦åˆæ³•
func isValid(s: [Character], start: Int, end: Int) -> Bool {
    guard start <= end, start >= 0, end < s.count else { return false } // ç´¢å¼•ä¸åˆæ³•
    if start != end, s[start] == "0" { return false } // ä»¥0å¼€å¤´çš„å¤šä½æ•°å­—ä¸åˆæ³•
    var num = 0
    for i in start ... end {
        let c = s[i]
        guard c >= "0", c <= "9" else { return false } // éæ•°å­—ä¸åˆæ³•
        let value = c.asciiValue! - ("0" as Character).asciiValue!
        num = num * 10 + Int(value)
        guard num <= 255 else { return false } // å¤§äº255ä¸åˆæ³•
    }
    return true
}
func restoreIpAddresses(_ s: String) -> [String] {
    var s = Array(s) // è½¬æ¢æˆå­—ç¬¦æ•°ç»„ä»¥ä¾¿äºæ¯”è¾ƒ
    var result = [String]() // ç»“æœ
    func backtracking(startIndex: Int, pointCount: Int) {
        guard startIndex < s.count else { return } // ç´¢å¼•ä¸åˆæ³•
        // ç»“æŸæ¡ä»¶
        if pointCount == 3 {
            // æœ€åä¸€æ®µä¹Ÿåˆæ³•ï¼Œåˆ™æ”¶é›†ç»“æœ
            if isValid(s: s, start: startIndex, end: s.count - 1) {
                result.append(String(s))
            }
            return
        }

        for i in startIndex ..< s.count {
            // åˆ¤æ–­[starIndex, i]å­ä¸²æ˜¯å¦åˆæ³•ï¼Œåˆæ³•åˆ™æ’å…¥â€œ.â€ï¼Œå¦åˆ™ç»“æŸæœ¬å±‚å¾ªç¯
            if isValid(s: s, start: startIndex, end: i) {
                s.insert(".", at: i + 1) // å­ä¸²åé¢æ’å…¥â€œ.â€
                backtracking(startIndex: i + 2, pointCount: pointCount + 1) // æ³¨æ„è¿™é‡Œæ—¶è·³2ä½ï¼Œä¸”é€šè¿‡pointCount + 1å±€éƒ¨å˜é‡éšè—äº†pointCountçš„å›æº¯
                s.remove(at: i + 1) // å›æº¯
            } else {
                break
            }
        }
    }
    backtracking(startIndex: 0, pointCount: 0)
    return result
}
```

* []

```scala
object Solution {
  import scala.collection.mutable
  def restoreIpAddresses(s: String): List[String] = {
    var result = mutable.ListBuffer[String]()
    if (s.size < 4 || s.length > 12) return result.toList
    var path = mutable.ListBuffer[String]()

    // åˆ¤æ–­IPä¸­çš„ä¸€ä¸ªå­—æ®µæ˜¯å¦ä¸ºæ­£ç¡®çš„
    def isIP(sub: String): Boolean = {
      if (sub.size > 1 && sub(0) == '0') return false
      if (sub.toInt > 255) return false
      true
    }

    def backtracking(startIndex: Int): Unit = {
      if (startIndex >= s.size) {
        if (path.size == 4) {
          result.append(path.mkString(".")) // mkStringæ–¹æ³•å¯ä»¥æŠŠé›†åˆé‡Œçš„æ•°æ®ä»¥æŒ‡å®šå­—ç¬¦ä¸²æ‹¼æ¥
          return
        }
        return
      }
      // subString
      for (i <- startIndex until startIndex + 3 if i < s.size) {
        var subString = s.substring(startIndex, i + 1)
        if (isIP(subString)) { // å¦‚æœåˆæ³•åˆ™è¿›è¡Œä¸‹ä¸€è½®
          path.append(subString)
          backtracking(i + 1)
          path = path.take(path.size - 1)
        }
      }
    }

    backtracking(0)
    result.toList
  }
}
```

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

