**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[å›æº¯ç®—æ³•ä¸­çš„å»é‡ï¼Œæ ‘å±‚å»é‡æ ‘æå»é‡ï¼Œä½ å¼„æ¸…æ¥šäº†æ²¡ï¼Ÿ| LeetCode:40.ç»„åˆæ€»å’ŒII](https://www.bilibili.com/video/BV12V4y1V73A)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

# æ€è·¯

è¿™é“é¢˜ç›®å’Œ[39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)å¦‚ä¸‹åŒºåˆ«ï¼š

1. æœ¬é¢˜candidatesÂ ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚
2. æœ¬é¢˜æ•°ç»„candidatesçš„å…ƒç´ æ˜¯æœ‰é‡å¤çš„ï¼Œè€Œ[39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)æ˜¯æ— é‡å¤å…ƒç´ çš„æ•°ç»„candidates

æœ€åæœ¬é¢˜å’Œ[39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)è¦æ±‚ä¸€æ ·ï¼Œè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚

**æœ¬é¢˜çš„éš¾ç‚¹åœ¨äºåŒºåˆ«2ä¸­ï¼šé›†åˆï¼ˆæ•°ç»„candidatesï¼‰æœ‰é‡å¤å…ƒç´ ï¼Œä½†è¿˜ä¸èƒ½æœ‰é‡å¤çš„ç»„åˆ**ã€‚

ä¸€äº›åŒå­¦å¯èƒ½æƒ³äº†ï¼šæˆ‘æŠŠæ‰€æœ‰ç»„åˆæ±‚å‡ºæ¥ï¼Œå†ç”¨setæˆ–è€…mapå»é‡ï¼Œè¿™ä¹ˆåšå¾ˆå®¹æ˜“è¶…æ—¶ï¼

æ‰€ä»¥è¦åœ¨æœç´¢çš„è¿‡ç¨‹ä¸­å°±å»æ‰é‡å¤ç»„åˆã€‚

å¾ˆå¤šåŒå­¦åœ¨å»é‡çš„é—®é¢˜ä¸Šæƒ³ä¸æ˜ç™½ï¼Œå…¶å®å¾ˆå¤šé¢˜è§£ä¹Ÿæ²¡æœ‰è®²æ¸…æ¥šï¼Œåæ­£ä»£ç æ˜¯èƒ½è¿‡çš„ï¼Œæ„Ÿè§‰æ˜¯é‚£ä¹ˆå›äº‹ï¼Œç¨€é‡Œç³Šæ¶‚çš„å…ˆæŠŠé¢˜ç›®è¿‡äº†ã€‚

è¿™ä¸ªå»é‡ä¸ºä»€ä¹ˆå¾ˆéš¾ç†è§£å‘¢ï¼Œ**æ‰€è°“å»é‡ï¼Œå…¶å®å°±æ˜¯ä½¿ç”¨è¿‡çš„å…ƒç´ ä¸èƒ½é‡å¤é€‰å–ã€‚** è¿™ä¹ˆä¸€è¯´å¥½åƒå¾ˆç®€å•ï¼

éƒ½çŸ¥é“ç»„åˆé—®é¢˜å¯ä»¥æŠ½è±¡ä¸ºæ ‘å½¢ç»“æ„ï¼Œé‚£ä¹ˆâ€œä½¿ç”¨è¿‡â€åœ¨è¿™ä¸ªæ ‘å½¢ç»“æ„ä¸Šæ˜¯æœ‰ä¸¤ä¸ªç»´åº¦çš„ï¼Œä¸€ä¸ªç»´åº¦æ˜¯åŒä¸€æ ‘æä¸Šä½¿ç”¨è¿‡ï¼Œä¸€ä¸ªç»´åº¦æ˜¯åŒä¸€æ ‘å±‚ä¸Šä½¿ç”¨è¿‡ã€‚**æ²¡æœ‰ç†è§£è¿™ä¸¤ä¸ªå±‚é¢ä¸Šçš„â€œä½¿ç”¨è¿‡â€ æ˜¯é€ æˆå¤§å®¶æ²¡æœ‰å½»åº•ç†è§£å»é‡çš„æ ¹æœ¬åŸå› ã€‚**

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œæˆ‘ä»¬æ˜¯è¦åŒä¸€æ ‘å±‚ä¸Šä½¿ç”¨è¿‡ï¼Œè¿˜æ˜¯åŒä¸€æ ‘æä¸Šä½¿ç”¨è¿‡å‘¢ï¼Ÿ

å›çœ‹ä¸€ä¸‹é¢˜ç›®ï¼Œå…ƒç´ åœ¨åŒä¸€ä¸ªç»„åˆå†…æ˜¯å¯ä»¥é‡å¤çš„ï¼Œæ€ä¹ˆé‡å¤éƒ½æ²¡äº‹ï¼Œä½†ä¸¤ä¸ªç»„åˆä¸èƒ½ç›¸åŒã€‚

**æ‰€ä»¥æˆ‘ä»¬è¦å»é‡çš„æ˜¯åŒä¸€æ ‘å±‚ä¸Šçš„â€œä½¿ç”¨è¿‡â€ï¼ŒåŒä¸€æ ‘æä¸Šçš„éƒ½æ˜¯ä¸€ä¸ªç»„åˆé‡Œçš„å…ƒç´ ï¼Œä¸ç”¨å»é‡**ã€‚

ä¸ºäº†ç†è§£å»é‡æˆ‘ä»¬æ¥ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œcandidates = [1, 1, 2], target = 3ï¼Œï¼ˆæ–¹ä¾¿èµ·è§candidateså·²ç»æ’åºäº†ï¼‰

**å¼ºè°ƒä¸€ä¸‹ï¼Œæ ‘å±‚å»é‡çš„è¯ï¼Œéœ€è¦å¯¹æ•°ç»„æ’åºï¼**

é€‰æ‹©è¿‡ç¨‹æ ‘å½¢ç»“æ„å¦‚å›¾æ‰€ç¤ºï¼š

![image.png](https://pic.leetcode.cn/1672110919-KHhJDC-image.png)

å¯ä»¥çœ‹åˆ°å›¾ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹ç›¸å¯¹äº [39.ç»„åˆæ€»å’Œ](https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw)æˆ‘å¤šåŠ äº†usedæ•°ç»„ï¼Œè¿™ä¸ªusedæ•°ç»„ä¸‹é¢ä¼šé‡ç‚¹ä»‹ç»ã€‚

## å›æº¯ä¸‰éƒ¨æ›²

* **é€’å½’å‡½æ•°å‚æ•°**

ä¸[39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)å¥—è·¯ç›¸åŒï¼Œæ­¤é¢˜è¿˜éœ€è¦åŠ ä¸€ä¸ªboolå‹æ•°ç»„usedï¼Œç”¨æ¥è®°å½•åŒä¸€æ ‘æä¸Šçš„å…ƒç´ æ˜¯å¦ä½¿ç”¨è¿‡ã€‚

è¿™ä¸ªé›†åˆå»é‡çš„é‡ä»»å°±æ˜¯usedæ¥å®Œæˆçš„ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
vector<vector<int>> result; // å­˜æ”¾ç»„åˆé›†åˆ
vector<int> path;           // ç¬¦åˆæ¡ä»¶çš„ç»„åˆ
void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
```

* **é€’å½’ç»ˆæ­¢æ¡ä»¶**

ä¸[39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)ç›¸åŒï¼Œç»ˆæ­¢æ¡ä»¶ä¸º `sum > target` å’Œ `sum == target`ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
if (sum > target) { // è¿™ä¸ªæ¡ä»¶å…¶å®å¯ä»¥çœç•¥
    return;
}
if (sum == target) {
    result.push_back(path);
    return;
}
```

`sum > target`  è¿™ä¸ªæ¡ä»¶å…¶å®å¯ä»¥çœç•¥ï¼Œå› ä¸ºåœ¨é€’å½’å•å±‚éå†çš„æ—¶å€™ï¼Œä¼šæœ‰å‰ªæçš„æ“ä½œï¼Œä¸‹é¢ä¼šä»‹ç»åˆ°ã€‚

* **å•å±‚æœç´¢çš„é€»è¾‘**

è¿™é‡Œä¸[39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)æœ€å¤§çš„ä¸åŒå°±æ˜¯è¦å»é‡äº†ã€‚

å‰é¢æˆ‘ä»¬æåˆ°ï¼šè¦å»é‡çš„æ˜¯â€œåŒä¸€æ ‘å±‚ä¸Šçš„ä½¿ç”¨è¿‡â€ï¼Œå¦‚ä½•åˆ¤æ–­åŒä¸€æ ‘å±‚ä¸Šå…ƒç´ ï¼ˆç›¸åŒçš„å…ƒç´ ï¼‰æ˜¯å¦ä½¿ç”¨è¿‡äº†å‘¢ã€‚

**å¦‚æœ`candidates[i] == candidates[i - 1]` å¹¶ä¸” `used[i - 1] == false`ï¼Œå°±è¯´æ˜ï¼šå‰ä¸€ä¸ªæ ‘æï¼Œä½¿ç”¨äº†candidates[i - 1]ï¼Œä¹Ÿå°±æ˜¯è¯´åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡candidates[i - 1]**ã€‚

æ­¤æ—¶forå¾ªç¯é‡Œå°±åº”è¯¥åšcontinueçš„æ“ä½œã€‚

è¿™å—æ¯”è¾ƒæŠ½è±¡ï¼Œå¦‚å›¾ï¼š

![image.png](https://pic.leetcode.cn/1672110999-tOgJKW-image.png)

æˆ‘åœ¨å›¾ä¸­å°†usedçš„å˜åŒ–ç”¨æ©˜é»„è‰²æ ‡æ³¨ä¸Šï¼Œå¯ä»¥çœ‹å‡ºåœ¨candidates[i] == candidates[i - 1]ç›¸åŒçš„æƒ…å†µä¸‹ï¼š

* used[i - 1] == trueï¼Œè¯´æ˜åŒä¸€æ ‘æcandidates[i - 1]ä½¿ç”¨è¿‡
* used[i - 1] == falseï¼Œè¯´æ˜åŒä¸€æ ‘å±‚candidates[i - 1]ä½¿ç”¨è¿‡

å¯èƒ½æœ‰çš„å½•å‹æƒ³ï¼Œä¸ºä»€ä¹ˆ used[i - 1] == false å°±æ˜¯åŒä¸€æ ‘å±‚å‘¢ï¼Œå› ä¸ºåŒä¸€æ ‘å±‚ï¼Œused[i - 1] == false æ‰èƒ½è¡¨ç¤ºï¼Œå½“å‰å–çš„ candidates[i] æ˜¯ä» candidates[i - 1] å›æº¯è€Œæ¥çš„ã€‚

è€Œ used[i - 1] == trueï¼Œè¯´æ˜æ˜¯è¿›å…¥ä¸‹ä¸€å±‚é€’å½’ï¼Œå»ä¸‹ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥æ˜¯æ ‘æä¸Šï¼Œå¦‚å›¾æ‰€ç¤ºï¼š

![image.png](https://pic.leetcode.cn/1672111042-cNXIfI-image.png)

**è¿™å—å»é‡çš„é€»è¾‘å¾ˆæŠ½è±¡ï¼Œç½‘ä¸Šæœçš„é¢˜è§£åŸºæœ¬æ²¡æœ‰èƒ½è®²æ¸…æ¥šçš„ï¼Œå¦‚æœå¤§å®¶ä¹‹å‰æ€è€ƒè¿‡è¿™ä¸ªé—®é¢˜æˆ–è€…åˆ·è¿‡è¿™é“é¢˜ç›®ï¼Œçœ‹åˆ°è¿™é‡Œä¸€å®šä¼šæ„Ÿè§‰é€šé€äº†å¾ˆå¤šï¼**

é‚£ä¹ˆå•å±‚æœç´¢çš„é€»è¾‘ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
    // used[i - 1] == trueï¼Œè¯´æ˜åŒä¸€æ ‘æcandidates[i - 1]ä½¿ç”¨è¿‡
    // used[i - 1] == falseï¼Œè¯´æ˜åŒä¸€æ ‘å±‚candidates[i - 1]ä½¿ç”¨è¿‡
    // è¦å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡
    if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
        continue;
    }
    sum += candidates[i];
    path.push_back(candidates[i]);
    used[i] = true;
    backtracking(candidates, target, sum, i + 1, used); // å’Œ39.ç»„åˆæ€»å’Œçš„åŒºåˆ«1ï¼šè¿™é‡Œæ˜¯i+1ï¼Œæ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡
    used[i] = false;
    sum -= candidates[i];
    path.pop_back();
}
```

**æ³¨æ„sum + candidates[i] <= targetä¸ºå‰ªææ“ä½œï¼Œåœ¨[39.ç»„åˆæ€»å’Œ](https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw)æœ‰è®²è§£è¿‡ï¼**

å›æº¯ä¸‰éƒ¨æ›²åˆ†æå®Œäº†ï¼Œæ•´ä½“C++ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == trueï¼Œè¯´æ˜åŒä¸€æ ‘æcandidates[i - 1]ä½¿ç”¨è¿‡
            // used[i - 1] == falseï¼Œè¯´æ˜åŒä¸€æ ‘å±‚candidates[i - 1]ä½¿ç”¨è¿‡
            // è¦å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target, sum, i + 1, used); // å’Œ39.ç»„åˆæ€»å’Œçš„åŒºåˆ«1ï¼Œè¿™é‡Œæ˜¯i+1ï¼Œæ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        path.clear();
        result.clear();
        // é¦–å…ˆæŠŠç»™candidatesæ’åºï¼Œè®©å…¶ç›¸åŒçš„å…ƒç´ éƒ½æŒ¨åœ¨ä¸€èµ·ã€‚
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};

```

## è¡¥å……

è¿™é‡Œç›´æ¥ç”¨startIndexæ¥å»é‡ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œ å°±ä¸ç”¨usedæ•°ç»„äº†ã€‚

* CPP

```CPP
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // è¦å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡
            if (i > startIndex && candidates[i] == candidates[i - 1]) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i + 1); // å’Œ39.ç»„åˆæ€»å’Œçš„åŒºåˆ«1ï¼Œè¿™é‡Œæ˜¯i+1ï¼Œæ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        path.clear();
        result.clear();
        // é¦–å…ˆæŠŠç»™candidatesæ’åºï¼Œè®©å…¶ç›¸åŒçš„å…ƒç´ éƒ½æŒ¨åœ¨ä¸€èµ·ã€‚
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return result;
    }
};

```

# æ€»ç»“

æœ¬é¢˜åŒæ ·æ˜¯æ±‚ç»„åˆæ€»å’Œï¼Œä½†å°±æ˜¯å› ä¸ºå…¶æ•°ç»„candidatesæœ‰é‡å¤å…ƒç´ ï¼Œè€Œè¦æ±‚ä¸èƒ½æœ‰é‡å¤çš„ç»„åˆï¼Œæ‰€ä»¥ç›¸å¯¹äº[39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)éš¾åº¦æå‡äº†ä¸å°‘ã€‚

**å…³é”®æ˜¯å»é‡çš„é€»è¾‘ï¼Œä»£ç å¾ˆç®€å•ï¼Œç½‘ä¸Šä¸€æœä¸€å¤§æŠŠï¼Œä½†å‡ ä¹æ²¡æœ‰èƒ½æŠŠè¿™å—ä»£ç å«ä¹‰è®²æ˜ç™½çš„ï¼ŒåŸºæœ¬éƒ½æ˜¯ç»™å‡ºä»£ç ï¼Œç„¶åè¯´è¿™å°±æ˜¯å»é‡äº†ï¼Œç©¶ç«Ÿæ€ä¹ˆä¸ªå»é‡æ³•ä¹Ÿæ˜¯æ¨¡æ£±ä¸¤å¯**ã€‚

æ‰€ä»¥Carlæœ‰å¿…è¦æŠŠå»é‡çš„è¿™å—å½»å½»åº•åº•çš„ç»™å¤§å®¶è®²æ¸…æ¥šï¼Œ**å°±è¿â€œæ ‘å±‚å»é‡â€å’Œâ€œæ ‘æå»é‡â€éƒ½æ˜¯æˆ‘è‡ªåˆ›çš„è¯æ±‡ï¼Œå¸Œæœ›å¯¹å¤§å®¶ç†è§£æœ‰å¸®åŠ©ï¼**

# å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```Java
// **ä½¿ç”¨æ ‡è®°æ•°ç»„**
class Solution {
  LinkedList<Integer> path = new LinkedList<>();
  List<List<Integer>> ans = new ArrayList<>();
  boolean[] used;
  int sum = 0;

  public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    used = new boolean[candidates.length];
    // åŠ æ ‡å¿—æ•°ç»„ï¼Œç”¨æ¥è¾…åŠ©åˆ¤æ–­åŒå±‚èŠ‚ç‚¹æ˜¯å¦å·²ç»éå†
    Arrays.fill(used, false);
    // ä¸ºäº†å°†é‡å¤çš„æ•°å­—éƒ½æ”¾åˆ°ä¸€èµ·ï¼Œæ‰€ä»¥å…ˆè¿›è¡Œæ’åº
    Arrays.sort(candidates);
    backTracking(candidates, target, 0);
    return ans;
  }

  private void backTracking(int[] candidates, int target, int startIndex) {
    if (sum == target) {
      ans.add(new ArrayList(path));
    }
    for (int i = startIndex; i < candidates.length; i++) {
      if (sum + candidates[i] > target) {
        break;
      }
      // å‡ºç°é‡å¤èŠ‚ç‚¹ï¼ŒåŒå±‚çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å·²ç»è¢«è®¿é—®è¿‡ï¼Œæ‰€ä»¥ç›´æ¥è·³è¿‡
      if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
        continue;
      }
      used[i] = true;
      sum += candidates[i];
      path.add(candidates[i]);
      // æ¯ä¸ªèŠ‚ç‚¹ä»…èƒ½é€‰æ‹©ä¸€æ¬¡ï¼Œæ‰€ä»¥ä»ä¸‹ä¸€ä½å¼€å§‹
      backTracking(candidates, target, i + 1);
      used[i] = false;
      sum -= candidates[i];
      path.removeLast();
    }
  }
}


// **ä¸ä½¿ç”¨æ ‡è®°æ•°ç»„**
class Solution {
  List<List<Integer>> res = new ArrayList<>();
  LinkedList<Integer> path = new LinkedList<>();
  int sum = 0;
  
  public List<List<Integer>> combinationSum2( int[] candidates, int target ) {
    //ä¸ºäº†å°†é‡å¤çš„æ•°å­—éƒ½æ”¾åˆ°ä¸€èµ·ï¼Œæ‰€ä»¥å…ˆè¿›è¡Œæ’åº
    Arrays.sort( candidates );
    backTracking( candidates, target, 0 );
    return res;
  }
  
  private void backTracking( int[] candidates, int target, int start ) {
    if ( sum == target ) {
      res.add( new ArrayList<>( path ) );
      return;
    }
    for ( int i = start; i < candidates.length && sum + candidates[i] <= target; i++ ) {
      //æ­£ç¡®å‰”é™¤é‡å¤è§£çš„åŠæ³•
      //è·³è¿‡åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ 
      if ( i > start && candidates[i] == candidates[i - 1] ) {
        continue;
      }

      sum += candidates[i];
      path.add( candidates[i] );
      // i+1 ä»£è¡¨å½“å‰ç»„å†…å…ƒç´ åªé€‰å–ä¸€æ¬¡
      backTracking( candidates, target, i + 1 );

      int temp = path.getLast();
      sum -= temp;
      path.removeLast();
    }
  }
}
```

* []

```python
# **å›æº¯+å·§å¦™å»é‡(çœå»ä½¿ç”¨used**
class Solution:
    def __init__(self):
        self.paths = []
        self.path = []

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        '''
        ç±»ä¼¼äºæ±‚ä¸‰æ•°ä¹‹å’Œï¼Œæ±‚å››æ•°ä¹‹å’Œï¼Œä¸ºäº†é¿å…é‡å¤ç»„åˆï¼Œéœ€è¦æå‰è¿›è¡Œæ•°ç»„æ’åº
        '''
        self.paths.clear()
        self.path.clear()
        # å¿…é¡»æå‰è¿›è¡Œæ•°ç»„æ’åºï¼Œé¿å…é‡å¤
        candidates.sort()
        self.backtracking(candidates, target, 0, 0)
        return self.paths

    def backtracking(self, candidates: List[int], target: int, sum_: int, start_index: int) -> None:
        # Base Case
        if sum_ == target:
            self.paths.append(self.path[:])
            return
        
        # å•å±‚é€’å½’é€»è¾‘
        for i in range(start_index, len(candidates)):
            # å‰ªæï¼ŒåŒ39.ç»„åˆæ€»å’Œ
            if sum_ + candidates[i] > target:
                return
            
            # è·³è¿‡åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ 
            if i > start_index and candidates[i] == candidates[i-1]:
                continue
            
            sum_ += candidates[i]
            self.path.append(candidates[i])
            self.backtracking(candidates, target, sum_, i+1)
            self.path.pop()             # å›æº¯ï¼Œä¸ºäº†ä¸‹ä¸€è½®for loop
            sum_ -= candidates[i]       # å›æº¯ï¼Œä¸ºäº†ä¸‹ä¸€è½®for loop

# **å›æº¯+å»é‡ï¼ˆä½¿ç”¨usedï¼‰**
class Solution:
    def __init__(self):
        self.paths = []
        self.path = []
        self.used = []

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        '''
        ç±»ä¼¼äºæ±‚ä¸‰æ•°ä¹‹å’Œï¼Œæ±‚å››æ•°ä¹‹å’Œï¼Œä¸ºäº†é¿å…é‡å¤ç»„åˆï¼Œéœ€è¦æå‰è¿›è¡Œæ•°ç»„æ’åº
        æœ¬é¢˜éœ€è¦ä½¿ç”¨usedï¼Œç”¨æ¥æ ‡è®°åŒºåˆ«åŒä¸€æ ‘å±‚çš„å…ƒç´ ä½¿ç”¨é‡å¤æƒ…å†µï¼šæ³¨æ„åŒºåˆ†é€’å½’çºµå‘éå†é‡åˆ°çš„é‡å¤å…ƒç´ ï¼Œå’Œforå¾ªç¯é‡åˆ°çš„é‡å¤å…ƒç´ ï¼Œè¿™ä¸¤è€…çš„åŒºåˆ«
        '''
        self.paths.clear()
        self.path.clear()
        self.usage_list = [False] * len(candidates)
        # å¿…é¡»æå‰è¿›è¡Œæ•°ç»„æ’åºï¼Œé¿å…é‡å¤
        candidates.sort()
        self.backtracking(candidates, target, 0, 0)
        return self.paths

    def backtracking(self, candidates: List[int], target: int, sum_: int, start_index: int) -> None:
        # Base Case
        if sum_ == target:
            self.paths.append(self.path[:])
            return
        
        # å•å±‚é€’å½’é€»è¾‘
        for i in range(start_index, len(candidates)):
            # å‰ªæï¼ŒåŒ39.ç»„åˆæ€»å’Œ
            if sum_ + candidates[i] > target:
                return
            
            # æ£€æŸ¥åŒä¸€æ ‘å±‚æ˜¯å¦å‡ºç°æ›¾ç»ä½¿ç”¨è¿‡çš„ç›¸åŒå…ƒç´ 
            # è‹¥æ•°ç»„ä¸­å‰åå…ƒç´ å€¼ç›¸åŒï¼Œä½†å‰è€…å´æœªè¢«ä½¿ç”¨(used == False)ï¼Œè¯´æ˜æ˜¯for loopä¸­çš„åŒä¸€æ ‘å±‚çš„ç›¸åŒå…ƒç´ æƒ…å†µ
            if i > 0 and candidates[i] == candidates[i-1] and self.usage_list[i-1] == False:
                continue

            sum_ += candidates[i]
            self.path.append(candidates[i])
            self.usage_list[i] = True
            self.backtracking(candidates, target, sum_, i+1)
            self.usage_list[i] = False  # å›æº¯ï¼Œä¸ºäº†ä¸‹ä¸€è½®for loop
            self.path.pop()             # å›æº¯ï¼Œä¸ºäº†ä¸‹ä¸€è½®for loop
            sum_ -= candidates[i]       # å›æº¯ï¼Œä¸ºäº†ä¸‹ä¸€è½®for loop
```

* []

```go
// **ä½¿ç”¨usedæ•°ç»„**
var (
    res [][]int
    path  []int
    used  []bool
)
func combinationSum2(candidates []int, target int) [][]int {
    res, path = make([][]int, 0), make([]int, 0, len(candidates))
    used = make([]bool, len(candidates))
    sort.Ints(candidates)   // æ’åºï¼Œä¸ºå‰ªæåšå‡†å¤‡
    dfs(candidates, 0, target)
    return res
}

func dfs(candidates []int, start int, target int) {
    if target == 0 {   // target ä¸æ–­å‡å°ï¼Œå¦‚æœä¸º0è¯´æ˜è¾¾åˆ°äº†ç›®æ ‡å€¼
        tmp := make([]int, len(path))
        copy(tmp, path)
        res = append(res, tmp)
        return
    }
    for i := start; i < len(candidates); i++ {
        if candidates[i] > target {  // å‰ªæï¼Œæå‰è¿”å›
            break
        }
        // used[i - 1] == trueï¼Œè¯´æ˜åŒä¸€æ ‘æcandidates[i - 1]ä½¿ç”¨è¿‡
        // used[i - 1] == falseï¼Œè¯´æ˜åŒä¸€æ ‘å±‚candidates[i - 1]ä½¿ç”¨è¿‡
        if i > 0 && candidates[i] == candidates[i-1]  && used[i-1] == false { 
            continue
        }
        path = append(path, candidates[i])
        used[i] = true
        dfs(candidates, i+1, target - candidates[i])
        used[i] = false
        path = path[:len(path) - 1]
    }
}

// **ä¸ä½¿ç”¨usedæ•°ç»„**
var (
    res [][]int
    path  []int
)
func combinationSum2(candidates []int, target int) [][]int {
    res, path = make([][]int, 0), make([]int, 0, len(candidates))
    sort.Ints(candidates)   // æ’åºï¼Œä¸ºå‰ªæåšå‡†å¤‡
    dfs(candidates, 0, target)
    return res
}

func dfs(candidates []int, start int, target int) {
    if target == 0 {   // target ä¸æ–­å‡å°ï¼Œå¦‚æœä¸º0è¯´æ˜è¾¾åˆ°äº†ç›®æ ‡å€¼
        tmp := make([]int, len(path))
        copy(tmp, path)
        res = append(res, tmp)
        return
    }
    for i := start; i < len(candidates); i++ {
        if candidates[i] > target {  // å‰ªæï¼Œæå‰è¿”å›
            break
        }
        // i != start é™åˆ¶äº†è¿™ä¸å¯¹æ·±åº¦éå†åˆ°è¾¾çš„æ­¤å€¼å»é‡
        if i != start && candidates[i] == candidates[i-1] { // å»é‡
            continue
        }
        path = append(path, candidates[i])
        dfs(candidates, i+1, target - candidates[i])
        path = path[:len(path) - 1]
    }
}
```

* []

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    const res = []; path = [], len = candidates.length;
    candidates.sort((a,b)=>a-b);
    backtracking(0, 0);
    return res;
    function backtracking(sum, i) {
        if (sum === target) {
            res.push(Array.from(path));
            return;
        }
        for(let j = i; j < len; j++) {
            const n = candidates[j];
            if(j > i && candidates[j] === candidates[j-1]){
              //è‹¥å½“å‰å…ƒç´ å’Œå‰ä¸€ä¸ªå…ƒç´ ç›¸ç­‰
              //åˆ™æœ¬æ¬¡å¾ªç¯ç»“æŸï¼Œé˜²æ­¢å‡ºç°é‡å¤ç»„åˆ
              continue;
            }
            //å¦‚æœå½“å‰å…ƒç´ å€¼å¤§äºç›®æ ‡å€¼-æ€»å’Œçš„å€¼
            //ç”±äºæ•°ç»„å·²æ’åºï¼Œé‚£ä¹ˆè¯¥å…ƒç´ ä¹‹åçš„å…ƒç´ å¿…å®šä¸æ»¡è¶³æ¡ä»¶
            //ç›´æ¥ç»ˆæ­¢å½“å‰å±‚çš„é€’å½’
            if(n > target - sum) break;
            path.push(n);
            sum += n;
            backtracking(sum, j + 1);
            path.pop();
            sum -= n;
        }
    }
};

 // **ä½¿ç”¨usedå»é‡**
var combinationSum2 = function(candidates, target) {
    let res = [];
    let path = [];
    let total = 0;
    const len = candidates.length;
    candidates.sort((a, b) => a - b);
    let used = new Array(len).fill(false);
    const backtracking = (startIndex) => {
        if (total === target) {
            res.push([...path]);
            return;
        }
        for(let i = startIndex; i < len && total < target; i++) {
            const cur = candidates[i];
            if (cur > target - total || (i > 0 && cur === candidates[i - 1] && !used[i - 1])) continue;
            path.push(cur);
            total += cur;
            used[i] = true;
            backtracking(i + 1);
            path.pop();
            total -= cur;
            used[i] = false;
        }
    }
    backtracking(0);
    return res;
};
```

* []

```typescript
function combinationSum2(candidates: number[], target: number): number[][] {
    candidates.sort((a, b) => a - b);
    const resArr: number[][] = [];
    function backTracking(
        candidates: number[], target: number,
        curSum: number, startIndex: number, route: number[]
    ) {
        if (curSum > target) return;
        if (curSum === target) {
            resArr.push(route.slice());
            return;
        }
        for (let i = startIndex, length = candidates.length; i < length; i++) {
            if (i > startIndex && candidates[i] === candidates[i - 1]) {
                continue;
            }
            let tempVal: number = candidates[i];
            route.push(tempVal);
            backTracking(candidates, target, curSum + tempVal, i + 1, route);
            route.pop();

        }
    }
    backTracking(candidates, target, 0, 0, []);
    return resArr;
};
```

* []

```Rust
impl Solution {
    pub fn backtracking(result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, candidates: &Vec<i32>, target: i32, mut sum: i32, start_index: usize, used: &mut Vec<bool>) {
        if sum == target {
            result.push(path.to_vec());
            return;
        }
        for i in start_index..candidates.len() {
            if sum + candidates[i] <= target {
                if i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false { continue; }
                sum += candidates[i];
                path.push(candidates[i]);
                used[i] = true;
                Self::backtracking(result, path, candidates, target, sum, i + 1, used);
                used[i] = false;
                sum -= candidates[i];
                path.pop();
            }
        }
    }

    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut path: Vec<i32> = Vec::new();
        let mut used: Vec<bool> = vec![false; candidates.len()];
        let mut candidates = candidates;
        candidates.sort();
        Self::backtracking(&mut result, &mut path, &candidates, target, 0, 0, &mut used);
        result
    }
}
```

* []

```c
int* path;
int pathTop;
int** ans;
int ansTop;
//è®°å½•ansä¸­æ¯ä¸€ä¸ªä¸€ç»´æ•°ç»„çš„å¤§å°
int* length;
int cmp(const void* a1, const void* a2) {
    return *((int*)a1) - *((int*)a2);
}

void backTracking(int* candidates, int candidatesSize,  int target, int sum, int startIndex) {
    if(sum >= target) {
        //è‹¥sumç­‰äºtargetï¼Œå¤åˆ¶å½“å‰pathè¿›å…¥
        if(sum == target) {
            int* tempPath = (int*)malloc(sizeof(int) * pathTop);
            int j;
            for(j = 0; j < pathTop; j++) {
                tempPath[j] = path[j];
            }
            length[ansTop] = pathTop;
            ans[ansTop++] = tempPath;
        }
        return ;
    }

    int i;
    for(i = startIndex; i < candidatesSize; i++) {
        //å¯¹åŒä¸€å±‚æ ‘ä¸­ä½¿ç”¨è¿‡çš„å…ƒç´ è·³è¿‡
        if(i > startIndex && candidates[i] == candidates[i-1])
            continue;
        path[pathTop++] = candidates[i];
        sum += candidates[i];
        backTracking(candidates, candidatesSize, target, sum, i + 1);
        //å›æº¯
        sum -= candidates[i];
        pathTop--;
    }
}

int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    path = (int*)malloc(sizeof(int) * 50);
    ans = (int**)malloc(sizeof(int*) * 100);
    length = (int*)malloc(sizeof(int) * 100);
    pathTop = ansTop = 0;
    //å¿«é€Ÿæ’åºcandidatesï¼Œè®©ç›¸åŒå…ƒç´ æŒ¨åˆ°ä¸€èµ·
    qsort(candidates, candidatesSize, sizeof(int), cmp);

    backTracking(candidates, candidatesSize, target, 0, 0);

    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = length[i];
    }
    return ans;
}
```

* []

```swift
func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {
    // ä¸ºäº†æ–¹ä¾¿å»é‡å¤ï¼Œå…ˆå¯¹é›†åˆæ’åº
    let candidates = candidates.sorted()
    var result = [[Int]]()
    var path = [Int]()
    func backtracking(sum: Int, startIndex: Int) {
        // ç»ˆæ­¢æ¡ä»¶
        if sum == target {
            result.append(path)
            return
        }

        let end = candidates.count
        guard startIndex < end else { return }
        for i in startIndex ..< end {
            if i > startIndex, candidates[i] == candidates[i - 1] { continue } // å»é‡å¤
            let sum = sum + candidates[i] // ä½¿ç”¨å±€éƒ¨å˜é‡éšè—å›æº¯
            if sum > target { continue } // å‰ªæ

            path.append(candidates[i]) // å¤„ç†
            backtracking(sum: sum, startIndex: i + 1) // i+1é¿å…é‡å¤è®¿é—®
            path.removeLast() // å›æº¯
        }
    }
    backtracking(sum: 0, startIndex: 0)
    return result
}
```

* []

```scala
object Solution {
  import scala.collection.mutable    
  def combinationSum2(candidates: Array[Int], target: Int): List[List[Int]] = {
    var res = mutable.ListBuffer[List[Int]]()
    var path = mutable.ListBuffer[Int]()
    var candidate = candidates.sorted

    def backtracking(sum: Int, startIndex: Int): Unit = {
      if (sum == target) {
        res.append(path.toList)
        return
      }

      for (i <- startIndex until candidate.size if sum + candidate(i) <= target) {
        if (!(i > startIndex && candidate(i) == candidate(i - 1))) {
          path.append(candidate(i))
          backtracking(sum + candidate(i), i + 1)
          path = path.take(path.size - 1)
        }
      }
    }

    backtracking(0, 0)
    res.toList
  }
}
```

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

