**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[è¿™å°±æ˜¯ä¼ è¯´ä¸­çš„Nçš‡åï¼Ÿ å›æº¯ç®—æ³•å®‰æ’ï¼| LeetCodeï¼š51.Nçš‡å](https://www.bilibili.com/video/BV1Rd4y1c7Bq/)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

## æ€è·¯

éƒ½çŸ¥é“nçš‡åé—®é¢˜æ˜¯å›æº¯ç®—æ³•è§£å†³çš„ç»å…¸é—®é¢˜ï¼Œä½†æ˜¯ç”¨å›æº¯è§£å†³å¤šäº†ç»„åˆã€åˆ‡å‰²ã€å­é›†ã€æ’åˆ—é—®é¢˜ä¹‹åï¼Œé‡åˆ°è¿™ç§äºŒç»´çŸ©é˜µè¿˜ä¼šæœ‰ç‚¹ä¸çŸ¥æ‰€æªã€‚

é¦–å…ˆæ¥çœ‹ä¸€ä¸‹çš‡åä»¬çš„çº¦æŸæ¡ä»¶ï¼š

1. ä¸èƒ½åŒè¡Œ
2. ä¸èƒ½åŒåˆ—
3. ä¸èƒ½åŒæ–œçº¿

ç¡®å®šå®Œçº¦æŸæ¡ä»¶ï¼Œæ¥çœ‹çœ‹ç©¶ç«Ÿè¦æ€ä¹ˆå»æœç´¢çš‡åä»¬çš„ä½ç½®ï¼Œå…¶å®æœç´¢çš‡åçš„ä½ç½®ï¼Œå¯ä»¥æŠ½è±¡ä¸ºä¸€æ£µæ ‘ã€‚

ä¸‹é¢æˆ‘ç”¨ä¸€ä¸ª 3 * 3 çš„æ£‹ç›˜ï¼Œå°†æœç´¢è¿‡ç¨‹æŠ½è±¡ä¸ºä¸€æ£µæ ‘ï¼Œå¦‚å›¾ï¼š

![image.png](https://pic.leetcode.cn/1674877647-vmvrqO-image.png)

ä»å›¾ä¸­ï¼Œå¯ä»¥çœ‹å‡ºï¼ŒäºŒç»´çŸ©é˜µä¸­çŸ©é˜µçš„é«˜å°±æ˜¯è¿™æ£µæ ‘çš„é«˜åº¦ï¼ŒçŸ©é˜µçš„å®½å°±æ˜¯æ ‘å½¢ç»“æ„ä¸­æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å®½åº¦ã€‚

é‚£ä¹ˆæˆ‘ä»¬ç”¨çš‡åä»¬çš„çº¦æŸæ¡ä»¶ï¼Œæ¥å›æº¯æœç´¢è¿™æ£µæ ‘ï¼Œ**åªè¦æœç´¢åˆ°äº†æ ‘çš„å¶å­èŠ‚ç‚¹ï¼Œè¯´æ˜å°±æ‰¾åˆ°äº†çš‡åä»¬çš„åˆç†ä½ç½®äº†**ã€‚

### å›æº¯ä¸‰éƒ¨æ›²

æŒ‰ç…§æˆ‘æ€»ç»“çš„å¦‚ä¸‹å›æº¯æ¨¡æ¿ï¼Œæˆ‘ä»¬æ¥ä¾æ¬¡åˆ†æï¼š

* 

```
void backtracking(å‚æ•°) {
    if (ç»ˆæ­¢æ¡ä»¶) {
        å­˜æ”¾ç»“æœ;
        return;
    }
    for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) {
        å¤„ç†èŠ‚ç‚¹;
        backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’
        å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
    }
}
```

* é€’å½’å‡½æ•°å‚æ•°

æˆ‘ä¾ç„¶æ˜¯å®šä¹‰å…¨å±€å˜é‡äºŒç»´æ•°ç»„resultæ¥è®°å½•æœ€ç»ˆç»“æœã€‚

å‚æ•°næ˜¯æ£‹ç›˜çš„å¤§å°ï¼Œç„¶åç”¨rowæ¥è®°å½•å½“å‰éå†åˆ°æ£‹ç›˜çš„ç¬¬å‡ å±‚äº†ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
vector<vector<string>> result;
void backtracking(int n, int row, vector<string>& chessboard) {
```

* é€’å½’ç»ˆæ­¢æ¡ä»¶

åœ¨å¦‚ä¸‹æ ‘å½¢ç»“æ„ä¸­ï¼š
![image.png](https://pic.leetcode.cn/1674877647-vmvrqO-image.png)

å¯ä»¥çœ‹å‡ºï¼Œå½“é€’å½’åˆ°æ£‹ç›˜æœ€åº•å±‚ï¼ˆä¹Ÿå°±æ˜¯å¶å­èŠ‚ç‚¹ï¼‰çš„æ—¶å€™ï¼Œå°±å¯ä»¥æ”¶é›†ç»“æœå¹¶è¿”å›äº†ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
if (row == n) {
    result.push_back(chessboard);
    return;
}
```

* å•å±‚æœç´¢çš„é€»è¾‘

é€’å½’æ·±åº¦å°±æ˜¯rowæ§åˆ¶æ£‹ç›˜çš„è¡Œï¼Œæ¯ä¸€å±‚é‡Œforå¾ªç¯çš„colæ§åˆ¶æ£‹ç›˜çš„åˆ—ï¼Œä¸€è¡Œä¸€åˆ—ï¼Œç¡®å®šäº†æ”¾ç½®çš‡åçš„ä½ç½®ã€‚

æ¯æ¬¡éƒ½æ˜¯è¦ä»æ–°çš„ä¸€è¡Œçš„èµ·å§‹ä½ç½®å¼€å§‹æœï¼Œæ‰€ä»¥éƒ½æ˜¯ä»0å¼€å§‹ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
for (int col = 0; col < n; col++) {
    if (isValid(row, col, chessboard, n)) { // éªŒè¯åˆæ³•å°±å¯ä»¥æ”¾
        chessboard[row][col] = 'Q'; // æ”¾ç½®çš‡å
        backtracking(n, row + 1, chessboard);
        chessboard[row][col] = '.'; // å›æº¯ï¼Œæ’¤é”€çš‡å
    }
}
```

* éªŒè¯æ£‹ç›˜æ˜¯å¦åˆæ³•

æŒ‰ç…§å¦‚ä¸‹æ ‡å‡†å»é‡ï¼š

1. ä¸èƒ½åŒè¡Œ
2. ä¸èƒ½åŒåˆ—
3. ä¸èƒ½åŒæ–œçº¿ ï¼ˆ45åº¦å’Œ135åº¦è§’ï¼‰

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
bool isValid(int row, int col, vector<string>& chessboard, int n) {
    // æ£€æŸ¥åˆ—
    for (int i = 0; i < row; i++) { // è¿™æ˜¯ä¸€ä¸ªå‰ªæ
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }
    // æ£€æŸ¥ 45åº¦è§’æ˜¯å¦æœ‰çš‡å
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    // æ£€æŸ¥ 135åº¦è§’æ˜¯å¦æœ‰çš‡å
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
```

åœ¨è¿™ä»½ä»£ç ä¸­ï¼Œç»†å¿ƒçš„åŒå­¦å¯ä»¥å‘ç°ä¸ºä»€ä¹ˆæ²¡æœ‰åœ¨åŒè¡Œè¿›è¡Œæ£€æŸ¥å‘¢ï¼Ÿ

å› ä¸ºåœ¨å•å±‚æœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€å±‚é€’å½’ï¼Œåªä¼šé€‰forå¾ªç¯ï¼ˆä¹Ÿå°±æ˜¯åŒä¸€è¡Œï¼‰é‡Œçš„ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥ä¸ç”¨å»é‡äº†ã€‚

é‚£ä¹ˆæŒ‰ç…§è¿™ä¸ªæ¨¡æ¿ä¸éš¾å†™å‡ºå¦‚ä¸‹C++ä»£ç ï¼š

* CPP

```CPP
class Solution {
private:
vector<vector<string>> result;
// n ä¸ºè¾“å…¥çš„æ£‹ç›˜å¤§å°
// row æ˜¯å½“å‰é€’å½’åˆ°æ£‹ç›˜çš„ç¬¬å‡ è¡Œäº†
void backtracking(int n, int row, vector<string>& chessboard) {
    if (row == n) {
        result.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isValid(row, col, chessboard, n)) { // éªŒè¯åˆæ³•å°±å¯ä»¥æ”¾
            chessboard[row][col] = 'Q'; // æ”¾ç½®çš‡å
            backtracking(n, row + 1, chessboard);
            chessboard[row][col] = '.'; // å›æº¯ï¼Œæ’¤é”€çš‡å
        }
    }
}
bool isValid(int row, int col, vector<string>& chessboard, int n) {
    // æ£€æŸ¥åˆ—
    for (int i = 0; i < row; i++) { // è¿™æ˜¯ä¸€ä¸ªå‰ªæ
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }
    // æ£€æŸ¥ 45åº¦è§’æ˜¯å¦æœ‰çš‡å
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    // æ£€æŸ¥ 135åº¦è§’æ˜¯å¦æœ‰çš‡å
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
public:
    vector<vector<string>> solveNQueens(int n) {
        result.clear();
        std::vector<std::string> chessboard(n, std::string(n, '.'));
        backtracking(n, 0, chessboard);
        return result;
    }
};
```

å¯ä»¥çœ‹å‡ºï¼Œé™¤äº†éªŒè¯æ£‹ç›˜åˆæ³•æ€§çš„ä»£ç ï¼Œçœä¸‹æ¥éƒ¨åˆ†å°±æ˜¯æŒ‰ç…§å›æº¯æ³•æ¨¡æ¿æ¥çš„ã€‚

## æ€»ç»“

æœ¬é¢˜æ˜¯æˆ‘ä»¬è§£å†³æ£‹ç›˜é—®é¢˜çš„ç¬¬ä¸€é“é¢˜ç›®ã€‚

å¦‚æœä»æ¥æ²¡æœ‰æ¥è§¦è¿‡Nçš‡åé—®é¢˜çš„åŒå­¦çœ‹ç€è¿™æ ·çš„é¢˜ä¼šæ„Ÿè§‰æ— ä»ä¸‹æ‰‹ï¼Œå¯èƒ½çŸ¥é“è¦ç”¨å›æº¯æ³•ï¼Œä½†ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆå»æœã€‚

**è¿™é‡Œæˆ‘æ˜ç¡®ç»™å‡ºäº†æ£‹ç›˜çš„å®½åº¦å°±æ˜¯forå¾ªç¯çš„é•¿åº¦ï¼Œé€’å½’çš„æ·±åº¦å°±æ˜¯æ£‹ç›˜çš„é«˜åº¦ï¼Œè¿™æ ·å°±å¯ä»¥å¥—è¿›å›æº¯æ³•çš„æ¨¡æ¿é‡Œäº†**ã€‚

å¤§å®¶å¯ä»¥åœ¨ä»”ç»†ä½“ä¼šä½“ä¼šï¼

## å…¶ä»–è¯­è¨€è¡¥å……

* []

```java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTrack(n, 0, chessboard);
        return res;
    }


    public void backTrack(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }

        for (int col = 0;col < n; ++col) {
            if (isValid (row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backTrack(n, row+1, chessboard);
                chessboard[row][col] = '.';
            }
        }

    }


    public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }


    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // æ£€æŸ¥åˆ—
        for (int i=0; i<row; ++i) { // ç›¸å½“äºå‰ªæ
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // æ£€æŸ¥45åº¦å¯¹è§’çº¿
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // æ£€æŸ¥135åº¦å¯¹è§’çº¿
        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}

// æ–¹æ³•2ï¼šä½¿ç”¨booleanæ•°ç»„è¡¨ç¤ºå·²ç»å ç”¨çš„ç›´(æ–œ)çº¿
class Solution {
    List<List<String>> res = new ArrayList<>();
    boolean[] usedCol, usedDiag45, usedDiag135;    // booleanæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä¸€æ¡ç›´(æ–œ)çº¿
    public List<List<String>> solveNQueens(int n) {
        usedCol = new boolean[n];                  // åˆ—æ–¹å‘çš„ç›´çº¿æ¡æ•°ä¸º n
        usedDiag45 = new boolean[2 * n - 1];       // 45Â°æ–¹å‘çš„æ–œçº¿æ¡æ•°ä¸º 2 * n - 1
        usedDiag135 = new boolean[2 * n - 1];      // 135Â°æ–¹å‘çš„æ–œçº¿æ¡æ•°ä¸º 2 * n - 1
		//ç”¨äºæ”¶é›†ç»“æœ, å…ƒç´ çš„indexè¡¨ç¤ºæ£‹ç›˜çš„rowï¼Œå…ƒç´ çš„valueä»£è¡¨æ£‹ç›˜çš„column
        int[] board = new int[n];
        backTracking(board, n, 0);
        return res;
    }
    private void backTracking(int[] board, int n, int row) {
        if (row == n) {
            //æ”¶é›†ç»“æœ
            List<String> temp = new ArrayList<>();
            for (int i : board) {
                char[] str = new char[n];
                Arrays.fill(str, '.');
                str[i] = 'Q';
                temp.add(new String(str));
            }
            res.add(temp);
            return;
        }

        for (int col = 0; col < n; col++) {
            if (usedCol[col] | usedDiag45[row + col] | usedDiag135[row - col + n - 1]) {
                continue;
            }
            board[row] = col;
			// æ ‡è®°è¯¥åˆ—å‡ºç°è¿‡
            usedCol[col] = true;
			// åŒä¸€45Â°æ–œçº¿ä¸Šå…ƒç´ çš„row + colä¸ºå®šå€¼, ä¸”å„ä¸ç›¸åŒ
            usedDiag45[row + col] = true;
			// åŒä¸€135Â°æ–œçº¿ä¸Šå…ƒç´ row - colä¸ºå®šå€¼, ä¸”å„ä¸ç›¸åŒ
			// row - col å€¼æœ‰æ­£æœ‰è´Ÿ, åŠ  n - 1 æ˜¯ä¸ºäº†å¯¹é½é›¶ç‚¹
            usedDiag135[row - col + n - 1] = true;
            // é€’å½’
            backTracking(board, n, row + 1);
            usedCol[col] = false;
            usedDiag45[row + col] = false;
            usedDiag135[row - col + n - 1] = false;
        }
    }
}
```

* []

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        if not n: return []
        board = [['.'] * n for _ in range(n)]
        res = []
        def isVaild(board,row, col):
            #åˆ¤æ–­åŒä¸€åˆ—æ˜¯å¦å†²çª
            for i in range(len(board)):
                if board[i][col] == 'Q':
                    return False
            # åˆ¤æ–­å·¦ä¸Šè§’æ˜¯å¦å†²çª
            i = row -1
            j = col -1
            while i>=0 and j>=0:
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            # åˆ¤æ–­å³ä¸Šè§’æ˜¯å¦å†²çª
            i = row - 1
            j = col + 1
            while i>=0 and j < len(board):
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True

        def backtracking(board, row, n):
            # å¦‚æœèµ°åˆ°æœ€åä¸€è¡Œï¼Œè¯´æ˜å·²ç»æ‰¾åˆ°ä¸€ä¸ªè§£
            if row == n:
                temp_res = []
                for temp in board:
                    temp_str = "".join(temp)
                    temp_res.append(temp_str)
                res.append(temp_res)
            for col in range(n):
                if not isVaild(board, row, col):
                    continue
                board[row][col] = 'Q'
                backtracking(board, row+1, n)
                board[row][col] = '.'
        backtracking(board, 0, n)
        return res
```

* []

```Go
func solveNQueens(n int) [][]string {
    var res [][]string
	chessboard := make([][]string, n)
	for i := 0; i < n; i++ {
		chessboard[i] = make([]string, n)
	}
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			chessboard[i][j] = "."
		}
	}
	var backtrack func(int)
	backtrack = func(row int) {
		if row == n {
			temp := make([]string, n)
			for i, rowStr := range chessboard {
				temp[i] = strings.Join(rowStr, "")
			}
			res = append(res, temp)
			return
		}
		for i := 0; i < n; i++ {
			if isValid(n, row, i, chessboard) {
				chessboard[row][i] = "Q"
				backtrack(row + 1)
				chessboard[row][i] = "."
			}
		}
	}
	backtrack(0)
	return res
}

func isValid(n, row, col int, chessboard [][]string) bool {
	for i := 0; i < row; i++ {
		if chessboard[i][col] == "Q" {
			return false
		}
	}
	for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 {
		if chessboard[i][j] == "Q" {
			return false
		}
	}
	for i, j := row-1, col+1; i >= 0 && j < n; i, j = i-1, j+1 {
		if chessboard[i][j] == "Q" {
			return false
		}
	}
	return true
}
```

* []

```Javascript
var solveNQueens = function(n) {
    function isValid(row, col, chessBoard, n) {

        for(let i = 0; i < row; i++) {
            if(chessBoard[i][col] === 'Q') {
                return false
            }
        }

        for(let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if(chessBoard[i][j] === 'Q') {
                return false
            }
        }

        for(let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if(chessBoard[i][j] === 'Q') {
                return false
            }
        }
        return true
    }

    function transformChessBoard(chessBoard) {
        let chessBoardBack = []
        chessBoard.forEach(row => {
            let rowStr = ''
            row.forEach(value => {
                rowStr += value
            })
            chessBoardBack.push(rowStr)
        })

        return chessBoardBack
    }

    let result = []
    function backtracing(row,chessBoard) {
        if(row === n) {
            result.push(transformChessBoard(chessBoard))
            return
        }
        for(let col = 0; col < n; col++) {
            if(isValid(row, col, chessBoard, n)) {
                chessBoard[row][col] = 'Q'
                backtracing(row + 1,chessBoard)
                chessBoard[row][col] = '.'
            }
        }
    }
    let chessBoard = new Array(n).fill([]).map(() => new Array(n).fill('.'))
    backtracing(0,chessBoard)
    return result
    
};
```

* []

```typescript
function solveNQueens(n: number): string[][] {
    const board: string[][] = new Array(n).fill(0).map(_ => new Array(n).fill('.'));
    const resArr: string[][] = [];
    backTracking(n, 0, board);
    return resArr;
    function backTracking(n: number, rowNum: number, board: string[][]): void {
        if (rowNum === n) {
            resArr.push(transformBoard(board));
            return;
        }
        for (let i = 0; i < n; i++) {
            if (isValid(i, rowNum, board) === true) {
                board[rowNum][i] = 'Q';
                backTracking(n, rowNum + 1, board);
                board[rowNum][i] = '.';
            }
        }
    }
};
function isValid(col: number, row: number, board: string[][]): boolean {
    const n: number = board.length;
    if (col < 0 || col >= n || row < 0 || row >= n) return false;
    // æ£€æŸ¥åˆ—
    for (let row of board) {
        if (row[col] === 'Q') return false;
    }
    // æ£€æŸ¥45åº¦æ–¹å‘
    let x: number = col,
        y: number = row;
    while (y >= 0 && x < n) {
        if (board[y--][x++] === 'Q') return false;
    }
    // æ£€æŸ¥135åº¦æ–¹å‘
    x = col;
    y = row;
    while (x >= 0 && y >= 0) {
        if (board[y--][x--] === 'Q') return false;
    }
    return true;
}
function transformBoard(board: string[][]): string[] {
    const resArr = [];
    for (let row of board) {
        resArr.push(row.join(''));
    }
    return resArr;
}
```

* []

```swift
func solveNQueens(_ n: Int) -> [[String]] {
    var result = [[String]]()
    // æ£‹ç›˜ï¼Œä½¿ç”¨Characterçš„äºŒç»´æ•°ç»„ï¼Œä»¥ä¾¿äºæ›´æ–°å…ƒç´ 
    var chessboard = [[Character]](repeating: [Character](repeating: ".", count: n), count: n)
    // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦ç¬¦åˆNçš‡å
    func isVaild(row: Int, col: Int) -> Bool {
        // æ£€æŸ¥åˆ—
        for i in 0 ..< row {
            if chessboard[i][col] == "Q" { return false }
        }

        var i, j: Int
        // æ£€æŸ¥45åº¦
        i = row - 1
        j = col - 1
        while i >= 0, j >= 0 {
            if chessboard[i][j] == "Q" { return false }
            i -= 1
            j -= 1
        }
        // æ£€æŸ¥135åº¦
        i = row - 1
        j = col + 1
        while i >= 0, j < n {
            if chessboard[i][j] == "Q" { return false }
            i -= 1
            j += 1
        }

        return true
    }
    func backtracking(row: Int) {
        if row == n {
            result.append(chessboard.map { String($0) })
        }

        for col in 0 ..< n {
            guard isVaild(row: row, col: col) else { continue }
            chessboard[row][col] = "Q" // æ”¾ç½®çš‡å
            backtracking(row: row + 1)
            chessboard[row][col] = "." // å›æº¯
        }
    }
    backtracking(row: 0)
    return result
}
```

* []

```Rust
impl Solution {
    fn is_valid(row: usize, col: usize, chessboard: &mut Vec<Vec<char>>, n: usize) -> bool {
        let mut i = 0 as usize;
        while i < row { 
            if chessboard[i][col] == 'Q' { return false; }
            i += 1;
        }
        let (mut i, mut j) = (row as i32 - 1, col as i32 - 1);
        while i >= 0 && j >= 0 {
            if chessboard[i as usize][j as usize] == 'Q' { return false; }
            i -= 1;
            j -= 1;
        }
        let (mut i, mut j) = (row as i32 - 1, col as i32 + 1);
        while i >= 0 && j < n as i32 {
            if chessboard[i as usize][j as usize] == 'Q' { return false; }
            i -= 1;
            j += 1;
        }
        return true;
    }
    fn backtracking(result: &mut Vec<Vec<String>>, n: usize, row: usize, chessboard: &mut Vec<Vec<char>>) {
        if row == n {
            let mut chessboard_clone: Vec<String> = Vec::new();
            for i in chessboard {
                chessboard_clone.push(i.iter().collect::<String>());
            }
            result.push(chessboard_clone);
            return;
        }
        for col in 0..n {
            if Self::is_valid(row, col, chessboard, n) {
                chessboard[row][col] = 'Q';
                Self::backtracking(result, n, row + 1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }
    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {
        let mut result: Vec<Vec<String>> = Vec::new();
        let mut chessboard: Vec<Vec<char>> = vec![vec!['.'; n as usize]; n as usize];
        Self::backtracking(&mut result, n as usize, 0, &mut chessboard);
        result
    }
}
```

* []

```c
char ***ans;
char **path;
int ansTop, pathTop;
//å°†pathä¸­å…ƒç´ å¤åˆ¶åˆ°ansä¸­
void copyPath(int n) {
    char **tempPath = (char**)malloc(sizeof(char*) * pathTop);
    int i;
    for(i = 0; i < pathTop; ++i) {
        tempPath[i] = (char*)malloc(sizeof(char) * n + 1);
        int j;
        for(j = 0; j < n; ++j)
            tempPath[i][j] = path[i][j];
        tempPath[i][j] = '\0';

    }
    ans[ansTop++] = tempPath;
}

//åˆ¤æ–­å½“å‰ä½ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆæ˜¯å¦ä¸è¢«å…¶å®ƒçš‡åå½±å“ï¼‰
int isValid(int x, int y, int n) {
    int i, j;
    //æ£€æŸ¥åŒä¸€è¡Œä»¥åŠåŒä¸€åˆ—æ˜¯å¦æœ‰æ•ˆ
    for(i = 0; i < n; ++i) {
        if(path[y][i] == 'Q' || path[i][x] == 'Q')
            return 0;
    }
    //ä¸‹é¢ä¸¤ä¸ªforå¾ªç¯æ£€æŸ¥æ–œè§’45åº¦æ˜¯å¦æœ‰æ•ˆ
    i = y - 1;
    j = x - 1;
    while(i >= 0 && j >= 0) {
        if(path[i][j] == 'Q')
            return 0;
        --i, --j;
    }

    i = y + 1;
    j = x + 1;
    while(i < n && j < n) {
        if(path[i][j] == 'Q')
            return 0;
        ++i, ++j;
    }

    //ä¸‹é¢ä¸¤ä¸ªforå¾ªç¯æ£€æŸ¥135åº¦æ˜¯å¦æœ‰æ•ˆ
    i = y - 1;
    j = x + 1;
    while(i >= 0 && j < n) {
        if(path[i][j] == 'Q')
            return 0;
        --i, ++j;
    }

    i = y + 1;
    j = x -1;
    while(j >= 0 && i < n) {
        if(path[i][j] == 'Q')
            return 0;
        ++i, --j;
    }
    return 1;
}

void backTracking(int n, int depth) {
    //è‹¥pathä¸­æœ‰å››ä¸ªå…ƒç´ ï¼Œå°†å…¶æ‹·è´åˆ°ansä¸­ã€‚ä»å½“å‰å±‚è¿”å›
    if(pathTop == n) {
        copyPath(n);
        return;
    }

    //éå†æ¨ªå‘æ£‹ç›˜
    int i;
    for(i = 0; i < n; ++i) {
        //è‹¥å½“å‰ä½ç½®æœ‰æ•ˆ
        if(isValid(i, depth, n)) {
            //åœ¨å½“å‰ä½ç½®æ”¾ç½®çš‡å
            path[depth][i] = 'Q';
            //pathä¸­å…ƒç´ æ•°é‡+1
            ++pathTop;

            backTracking(n, depth + 1);
            //è¿›è¡Œå›æº¯
            path[depth][i] = '.';
            //pathä¸­å…ƒç´ æ•°é‡-1
            --pathTop;
        }
    }
}

//åˆå§‹åŒ–å­˜å‚¨char*æ•°ç»„pathï¼Œå°†pathä¸­æ‰€æœ‰å…ƒç´ è®¾ä¸º'.'
void initPath(int n) {
    int i, j;
    for(i = 0; i < n; i++) {
        //ä¸ºpathä¸­æ¯ä¸ªchar*å¼€è¾Ÿç©ºé—´
        path[i] = (char*)malloc(sizeof(char) * n + 1);
        //å°†pathä¸­æ‰€æœ‰å­—ç¬¦è®¾ä¸º'.'
        for(j = 0; j < n; j++)
            path[i][j] = '.';
        //åœ¨æ¯ä¸ªå­—ç¬¦ä¸²ç»“å°¾åŠ å…¥'\0'
        path[i][j] = '\0';
    }
}

char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes){
    //åˆå§‹åŒ–è¾…åŠ©å˜é‡
    ans = (char***)malloc(sizeof(char**) * 400);
    path = (char**)malloc(sizeof(char*) * n);
    ansTop = pathTop = 0;

    //åˆå§‹åŒ–pathæ•°ç»„
    initPath(n);
    backTracking(n, 0);

    //è®¾ç½®è¿”å›æ•°ç»„å¤§å°
    *returnSize = ansTop;
    int i; 
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    for(i = 0; i < ansTop; ++i) {
        (*returnColumnSizes)[i] = n;
    }
    return ans;
}
```

* []

```scala
object Solution {
  import scala.collection.mutable
  def solveNQueens(n: Int): List[List[String]] = {
    var result = mutable.ListBuffer[List[String]]()

    def judge(x: Int, y: Int, maze: Array[Array[Boolean]]): Boolean = {
      // æ­£ä¸Šæ–¹
      var xx = x
      while (xx >= 0) {
        if (maze(xx)(y)) return false
        xx -= 1
      }
      // å·¦è¾¹
      var yy = y
      while (yy >= 0) {
        if (maze(x)(yy)) return false
        yy -= 1
      }
      // å·¦ä¸Šæ–¹
      xx = x
      yy = y
      while (xx >= 0 && yy >= 0) {
        if (maze(xx)(yy)) return false
        xx -= 1
        yy -= 1
      }
      xx = x
      yy = y
      // å³ä¸Šæ–¹
      while (xx >= 0 && yy < n) {
        if (maze(xx)(yy)) return false
        xx -= 1
        yy += 1
      }
      true
    }

    def backtracking(row: Int, maze: Array[Array[Boolean]]): Unit = {
      if (row == n) {
        // å°†ç»“æœè½¬æ¢ä¸ºé¢˜ç›®æ‰€éœ€è¦çš„å½¢å¼
        var path = mutable.ListBuffer[String]()
        for (x <- maze) {
          var tmp = mutable.ListBuffer[String]()
          for (y <- x) {
            if (y == true) tmp.append("Q")
            else tmp.append(".")
          }
          path.append(tmp.mkString)
        }
        result.append(path.toList)
        return
      }

      for (j <- 0 until n) {
        // åˆ¤æ–­è¿™ä¸ªä½ç½®æ˜¯å¦å¯ä»¥æ”¾ç½®çš‡å
        if (judge(row, j, maze)) {
          maze(row)(j) = true
          backtracking(row + 1, maze)
          maze(row)(j) = false
        }
      }
    }

    backtracking(0, Array.ofDim[Boolean](n, n))
    result.toList
  }
}
```

# å›æº¯ç®—æ³•åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ å›æº¯ç®—æ³•çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

* [å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)
* ç»„åˆé—®é¢˜
  * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
  * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
  * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
  * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
  * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜
  * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
  * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)
* å­é›†é—®é¢˜
  * [78.å­é›†](https://programmercarl.com/0078.å­é›†.html)
  * [90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)
* æ’åˆ—é—®é¢˜
  * [46.å…¨æ’åˆ—](https://programmercarl.com/0046.å…¨æ’åˆ—.html)
  * [47.å…¨æ’åˆ—II](https://programmercarl.com/0047.å…¨æ’åˆ—II.html)
* æ£‹ç›˜é—®é¢˜
  * [51.Nçš‡å](https://programmercarl.com/0051.Nçš‡å.html)
  * [37.è§£æ•°ç‹¬](https://programmercarl.com/0037.è§£æ•°ç‹¬.html)
* å…¶ä»–
  * [491.é€’å¢å­åºåˆ—](https://programmercarl.com/0491.é€’å¢å­åºåˆ—.html)
  * [332.é‡æ–°å®‰æ’è¡Œç¨‹](https://programmercarl.com/0332.é‡æ–°å®‰æ’è¡Œç¨‹.html)
* [å›æº¯ç®—æ³•æ€»ç»“ç¯‡](https://programmercarl.com/å›æº¯æ€»ç»“.html)

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

