### 解题思路

一般来说题目如果暗示你可以$O(n)$对序列进行操作的话，就可以考虑一下双指针的解法。这道题的双指针其实不是很明显，需要一定的思考。
首先还是对题目进行分析，其说明了数组实际上可以分为三段，有序+无序+有序，且两段有序肯定有前面一段都小于后面一段的，只需要确定无序的边界就可以。
做法就是维护一个max一个min来帮助确定边界，
先看max，如何维护？肯定是要遍历。既然都遍历了如何确定位置？这就要具体分析一下。比如我们直接考虑一个有序的数组`1 2 3 4`，从左到右遍历每次都更新了max；这时我们考虑`1 2 4 3`，那么max在遍历到4的时候就可以确定，但到3的时候发现了逆序，所以我们可以记录3，3其实就是无序的右边界。考虑更复杂的情况，相当于遍历中每一次都要更新max，然后比较当前的值和max的关系，如果小于max，则说明存在逆序（因为max肯定是在之前被更新的），就更新一下无序的右边界，最后被更新到的就是最终的右边界。
min的情况同理，只要从右往左更新min就可以。
这么一说可能还是有点绕，我们还是看题目的样例：
`2 6 4 8 10 9 15`
从左往右更新max的时候，会先被更新成6，遇到4的时候发现逆序了，把4更新成右边界，继续遇到8了更新成max，遇到10了更新成max，遇到9了，逆序，记录9为右边界，之后max更新成15。
从右往左更新min的时候，先是15，然后9，遇到10了逆序记录左边界，然后min更新成8，然后4，遇到6了逆序更新左边界，最后更新成2。
所以无序的区间就是从6到9的部分。
这个思路用到的想法就是，前后有两段有序的部分，在有序的部分，你从左往右更新max肯定是在一直更新的，从右往左更新min也是同理，但遇到了无序的部分就不一定，下个元素可能会小于max，也可能会大于min。因为无序一定有这一性质，那么记录这一条件最后得到的肯定是无序的左右边界。
代码用了一个trick可以一次遍历完成两次遍历的操作，其实就是玩弄了一下下标。
最后还要注意一点是如果数组本来就有序，那么不会记录到任何左右边界的更新，判断一下就好了。

### 代码

* cpp

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int n = nums.size();
        int maxn = INT_MIN, minn = INT_MAX;
        int l = -1, r = -1;
        for (int i = 0; i < n; ++i) {
            if (nums[i] < maxn)
                r = i;
            else
                maxn = max(maxn, nums[i]);
            if (nums[n - 1 - i] > minn)
                l = n - 1 - i;
            else
                minn = min(minn, nums[n - 1 - i]);
        }
        return r == -1 ? 0 : r - l + 1;
    }
};
```

